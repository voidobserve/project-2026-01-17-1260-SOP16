C51 COMPILER V9.60.7.0   MAIN                                                              01/17/2026 16:42:33 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Release\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\main.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\main.lst) OBJECT(.\Release\
                    -Objects\main.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    main.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    02-09-2022
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2021 HUGE-IC</center></h2>
  12           *
  13           * ç‰ˆæƒè¯´æ˜åç»­è¡¥ä¸Š
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "my_config.h"
  20          #include "include.h"
  21          
  22          #include <stdio.h>
  23          #include "power_on.h"
  24          
  25          
  26          
  27          
  28          
  29          #if USE_MY_DEBUG // æ‰“å°ä¸²å£é…ç½®
  30          
  31          #define UART0_BAUD 115200
  32          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUD) / (UART0_BAUD))
  33          // é‡å†™puchar()å‡½æ•°
  34          char putchar(char c)
  35          {
  36   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
  37   1              ;
  38   1          UART0_DATA = c;
  39   1          return c;
  40   1      }
  41          
  42          void my_debug_config(void)
  43          {
  44   1          // ä½œä¸ºå‘é€å¼•è„š
  45   1          // P1_MD0 &= (GPIO_P13_MODE_SEL(0x3));
  46   1          // P1_MD0 |= GPIO_P13_MODE_SEL(0x1);            // é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
  47   1          // FOUT_S13 |= GPIO_FOUT_UART0_TX;              // é…ç½®ä¸ºUART0_TX
  48   1          // UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // é…ç½®æ³¢ç‰¹ç‡é«˜å…«ä½
  49   1          // UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // é…ç½®æ³¢ç‰¹ç‡ä½å…«ä½
  50   1          // UART0_CON0 = UART_STOP_BIT(0x0) |
  51   1          //              UART_EN(0x1); // 8bitæ•°æ®ï¼Œ1bitåœæ­¢ä½
  52   1      
  53   1          P0_MD0 &= ~(GPIO_P00_MODE_SEL(0x3));
C51 COMPILER V9.60.7.0   MAIN                                                              01/17/2026 16:42:33 PAGE 2   

  54   1          P0_MD0 |= GPIO_P00_MODE_SEL(0x1);            // é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
  55   1          FOUT_S00 |= GPIO_FOUT_UART0_TX;              // é…ç½®ä¸ºUART0_TX
  56   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // é…ç½®æ³¢ç‰¹ç‡é«˜å…«ä½
  57   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // é…ç½®æ³¢ç‰¹ç‡ä½å…«ä½
  58   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  59   1                       UART_EN(0x1); // 8bitæ•°æ®ï¼Œ1bitåœæ­¢ä½
  60   1      }
  61          #endif // USE_MY_DEBUG // æ‰“å°ä¸²å£é…ç½®
  62          
  63          
  64          void main(void)
  65          {
  66   1          // çœ‹é—¨ç‹—é»˜è®¤æ‰“å¼€, å¤ä½æ—¶é—´2s
  67   1          WDT_KEY = WDT_KEY_VAL(0xDD); //  å…³é—­çœ‹é—¨ç‹— (å¦‚éœ€é…ç½®çœ‹é—¨ç‹—è¯·æŸ¥çœ‹â€œWDT\WDT_Resetâ€ç¤º
             -ä¾‹)
  68   1      
  69   1          system_init();
  70   1      
  71   1          // å…³é—­HCKå’ŒHDAçš„è°ƒè¯•åŠŸèƒ½
  72   1          WDT_KEY = 0x55;  // è§£é™¤å†™ä¿æŠ¤
  73   1          IO_MAP &= ~0x01; // æ¸…é™¤è¿™ä¸ªå¯„å­˜å™¨çš„å€¼ï¼Œå®ç°å…³é—­HCKå’ŒHDAå¼•è„šçš„è°ƒè¯•åŠŸèƒ½ï¼ˆè§£é™¤æ
             -˜ å°„ï¼‰
  74   1          WDT_KEY = 0xBB;  // å†™ä¸€ä¸ªæ— æ•ˆçš„æ•°æ®ï¼Œè§¦å‘å†™ä¿æŠ¤
  75   1      
  76   1      #if USE_MY_DEBUG // æ‰“å°ä¸²å£é…ç½®
  77   1          // åˆå§‹åŒ–æ‰“å°
  78   1      
  79   1          my_debug_config();
  80   1          printf("sys reset\n");
  81   1      
  82   1          // // P01 é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
  83   1          // P0_MD0 &= ~(0x03 << 2);
  84   1          // P0_MD0 |= 0x01 << 2;
  85   1          // FOUT_S01 = GPIO_FOUT_AF_FUNC;
  86   1          // P01 = 0;
  87   1      
  88   1          // // P02 é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
  89   1          // P0_MD0 &= ~(0x03 << 4); // æ¸…ç©ºå¯¹åº”çš„å¯„å­˜å™¨é…ç½®
  90   1          // P0_MD0 |= 0x01 << 4;    // è¾“å‡ºæ¨¡å¼
  91   1          // FOUT_S02 = GPIO_FOUT_AF_FUNC;
  92   1          // P02 = 0;
  93   1      
  94   1          // // P05 é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
  95   1          // P0_MD1 &= ~(0x03 << 2);
  96   1          // P0_MD1 |= 0x01 << 2;
  97   1          // FOUT_S05 = GPIO_FOUT_AF_FUNC;
  98   1          // P05 = 0;
  99   1      
 100   1          // // P06 é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
 101   1          // P0_MD1 &= ~(0x03 << 4);
 102   1          // P0_MD1 |= 0x01 << 4;
 103   1          // FOUT_S06 = GPIO_FOUT_AF_FUNC;
 104   1          // P06 = 0;
 105   1      
 106   1          // // P21 é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
 107   1          // P2_MD0 &= ~(0x03 << 2);
 108   1          // P2_MD0 |= 0x01 << 2; // è¾“å‡ºæ¨¡å¼
 109   1          // FOUT_S21 = GPIO_FOUT_AF_FUNC;
 110   1          // P21 = 0;
 111   1      
 112   1          // è¾“å‡ºæ¨¡å¼ï¼š
 113   1          // P1_MD0 &= (GPIO_P13_MODE_SEL(0x3));
C51 COMPILER V9.60.7.0   MAIN                                                              01/17/2026 16:42:33 PAGE 3   

 114   1          // P1_MD0 |= GPIO_P13_MODE_SEL(0x1); // é…ç½®ä¸ºè¾“å‡ºæ¨¡å¼
 115   1          // FOUT_S13 = GPIO_FOUT_AF_FUNC;     // é€‰æ‹©AFåŠŸèƒ½è¾“å‡º
 116   1      
 117   1          P2_MD1 &= ~(GPIO_P26_MODE_SEL(0x3));
 118   1          P2_MD1 |= GPIO_P26_MODE_SEL(0x01); // è¾“å‡ºæ¨¡å¼
 119   1          FOUT_S26 = GPIO_FOUT_AF_FUNC;
 120   1      #endif // æ‰“å°ä¸²å£é…ç½®
 121   1      
 122   1      #if 1
 123   1          adc_pin_config(); // é…ç½®ä½¿ç”¨åˆ°adcçš„å¼•è„š
 124   1          adc_config();
 125   1      
 126   1          tmr0_config(); //   
 127   1          pwm_init();    // é…ç½®pwmè¾“å‡ºçš„å¼•è„š
 128   1          tmr1_config();
 129   1      
 130   1          timer2_config();
 131   1          timer3_config(); // è¦ç­‰adcå®Œæˆåˆå§‹åŒ–ï¼Œå†è°ƒç”¨timer3çš„åˆå§‹åŒ–
 132   1      
 133   1          rf_recv_init(); // rfåŠŸèƒ½åˆå§‹åŒ–
 134   1          fan_ctl_config();
 135   1      
 136   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03); // P14 16è„š
 137   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
 138   1          FOUT_S14 = GPIO_FOUT_AF_FUNC; // AFåŠŸèƒ½è¾“å‡º
 139   1          P14 = 0;                      //
 140   1      #endif
 141   1      
 142   1          // limited_max_pwm_duty = MAX_PWM_DUTY;
 143   1          limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
 144   1          limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
 145   1          limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
 146   1      
 147   1          power_on_handle();
 148   1      
 149   1          while (1)
 150   1          {
 151   2      #if 1
 152   2              // USER_TO_DO æµ‹è¯•çš„æ—¶å€™æš‚æ—¶å±è”½
 153   2              // update_max_pwm_duty_coefficient(); // æ ¹æ®å½“å‰æ—‹é’®çš„æŒ¡ä½ï¼Œé™åˆ¶èƒ½è°ƒèŠ‚åˆ°çš„æœ€å¤§
             -çš„pwmå ç©ºæ¯”
 154   2              temperature_scan();                // æ£€æµ‹çƒ­æ•ç”µé˜»ä¸€ç«¯çš„ç”µå‹å€¼
 155   2              fan_scan();                        // æ£€æµ‹é£æ‰‡çš„çŠ¶æ€æ˜¯å¦å¼‚å¸¸ï¼Œå¹¶æ ¹æ®ç»“æœæ¥é™åˆ¶
             -pwmå ç©ºæ¯”
 156   2              set_duty();                        // è®¾å®šåˆ°è¦è°ƒèŠ‚åˆ°çš„è„‰å®½ (è®¾ç½®adjust_duty)
 157   2      
 158   2              if (flag_is_rf_enable) // å¦‚æœä½¿èƒ½äº†rfé¥æ§å™¨çš„åŠŸèƒ½
 159   2              {
 160   3                  key_driver_scan(&rf_key_para);
 161   3                  rf_key_handle();
 162   3              }
 163   2      
 164   2              {
 165   3                  // å¦‚æœ expect_adjust_pwm_channel_x_duty æœ‰å˜åŒ–ï¼Œå¯ä»¥åœ¨è¿™é‡Œä¿®æ”¹ adjust_pwm_channe
             -l_x_duty
 166   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 167   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 168   3              }
 169   2      
 170   2              // é£æ‰‡æ§åˆ¶ï¼š
 171   2              fan_ctl();
 172   2      #endif
C51 COMPILER V9.60.7.0   MAIN                                                              01/17/2026 16:42:33 PAGE 4   

 173   2      
 174   2              // P02 = ~P02; // æµ‹è¯•ä¸»å¾ªç¯ä¸€è½®æ‰€éœ€æ—¶é—´
 175   2      
 176   2              // æµ‹è¯•ç”¨ï¼š
 177   2              // {
 178   2              //     static u16 cnt = 0;
 179   2              //     cnt++;
 180   2      
 181   2              //     // if (cnt >= 10)
 182   2              //     if (cnt >= 100)
 183   2              //     {
 184   2              //         cnt = 0;
 185   2              //         // printf("expect_adjust_pwm_channel_0_duty: %u\n", expect_adjust_pwm_channel_0_duty);
 186   2              //         // printf("expect_adjust_pwm_channel_1_duty: %u\n", expect_adjust_pwm_channel_1_duty);
 187   2              //         // printf("adjust_pwm_channel_0_duty: %u\n", adjust_pwm_channel_0_duty);
 188   2              //         // printf("adjust_pwm_channel_1_duty: %u\n", adjust_pwm_channel_1_duty);
 189   2              //         // printf("cur_pwm_channel_0_duty: %u\n", cur_pwm_channel_0_duty);
 190   2              //         // printf("cur_pwm_channel_1_duty: %u\n", cur_pwm_channel_1_duty);
 191   2      
 192   2              //         // printf("__LINE__ %u\n", __LINE__);
 193   2              //         // printf("val %u\n", ADC_OVER_DRIVE_VAL);
 194   2              //         // printf("val %u\n", (u16)adc_val_from_fan);
 195   2              //         // printf("val %u\n", (u16)adc_val_from_temp);
 196   2              //         // printf("val %u\n", (u16)adc_val_from_knob);
 197   2              //         // printf("val %u\n", (u16)adc_val_from_engine);
 198   2      
 199   2              //         // P02 = ~P02;
 200   2              //     }
 201   2              // }
 202   2          }
 203   1      }
 204          
 205          /**
 206           * @}
 207           */
 208          
 209          /*************************** (C) COPYRIGHT 2022 HUGE-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    221    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
