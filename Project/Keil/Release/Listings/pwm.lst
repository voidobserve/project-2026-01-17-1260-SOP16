C51 COMPILER V9.60.7.0   PWM                                                               01/17/2026 16:42:33 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\Ob
                    -jects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
   6          // ç”±äºå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
   8          // ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä
             -¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   9          volatile u16 limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
  10          
  11          volatile u16 cur_pwm_channel_0_duty;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å ç©
             -ºæ¯”ï¼ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  12          volatile u16 expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_0 å
             - ç©ºæ¯”
  13          volatile u16 adjust_pwm_channel_0_duty = MAX_PWM_DUTY;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  14          
  15          volatile u16 cur_pwm_channel_1_duty;                          // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”ï¼
             -ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  16          volatile u16 expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_1 å
             - ç©ºæ¯”
  17          volatile u16 adjust_pwm_channel_1_duty = MAX_PWM_DUTY;        // pwm_channle_1 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  18          
  19          #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  20          #define STMR1_PEROID_VAL (SYSCLK / 8000 - 1)
  21          void pwm_init(void)
  22          {
  23   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  24   1      
  25   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  26   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  27   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  28   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  29   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  30   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  31   1      
  32   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  33   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  34   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  35   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  36   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  37   1      
  38   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  39   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  40   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  41   1      
  42   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  43   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  44   1          STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  45   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  46   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  47   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
C51 COMPILER V9.60.7.0   PWM                                                               01/17/2026 16:42:33 PAGE 2   

  48   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  49   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºç­‰äºæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºè¾“å‡º0 )
  50   1      
  51   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  52   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  53   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  54   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  55   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  56   1      
  57   1      #if USE_MY_TEST_PIN
                  P0_MD1 &= ~GPIO_P05_MODE_SEL(0x03); // ç”¨å¼€å‘æ¿ä¸Šçš„ p05
                  P0_MD1 |= GPIO_P05_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
              #else
  62   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  63   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  64   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  65   1      #endif //  #if USE_MY_TEST_PIN
  66   1      }
  67          
  68          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  69          void set_pwm_channel_0_duty(u16 channel_duty)
  70          {
  71   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  72   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  73   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  74   1      }
  75          
  76          // è®¾ç½®é€šé“1çš„å ç©ºæ¯”
  77          void set_pwm_channel_1_duty(u16 channel_duty)
  78          {
  79   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  80   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  81   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  82   1      }
  83          
  84          // æ ¹æ®9è„šçš„ç”µå‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡å‹ä¿æŠ¤ï¼‰
  85          // void according_pin9_to_adjust_pin16(void)
  86          // {
  87          //     // å½“9è„šç”µå‹é«˜äº 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºæ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºå…³æœºï
             -¼‰ã€‚
  88          //     // if (adc_val_pin_9 >= 3511)
  89          //     // {
  90          //     //     P14 = 1;
  91          //     // }
  92          //     // else if (adc_val_pin_9 <= 3511 - 40)
  93          //     {
  94          //         P14 = 0;
  95          //     }
  96          // }
  97          
  98          /**
  99           * @brief è·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
 100           *
 101           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 102           */
 103          u8 get_pwm_channel_0_status(void)
 104          {
 105   1          if (STMR_PWMEN & 0x01) // å¦‚æœpwm0ä½¿èƒ½
 106   1          {
 107   2              return 1;
C51 COMPILER V9.60.7.0   PWM                                                               01/17/2026 16:42:33 PAGE 3   

 108   2          }
 109   1          else // å¦‚æœpwm0æœªä½¿èƒ½
 110   1          {
 111   2              return 0;
 112   2          }
 113   1      }
 114          
 115          /**
 116           * @brief è·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 117           *
 118           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 119           */
 120          u8 get_pwm_channel_1_status(void)
 121          {
 122   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æœpwm1ä½¿èƒ½
 123   1          {
 124   2              return 1;
 125   2          }
 126   1          else // å¦‚æœ pwm æœªä½¿èƒ½
 127   1          {
 128   2              return 0;
 129   2          }
 130   1      }
 131          
 132          void pwm_channel_0_enable(void)
 133          {
 134   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 135   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 136   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 137   1      }
 138          
 139          void pwm_channel_0_disable(void)
 140          {
 141   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 142   1          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 143   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 144   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 145   1      }
 146          
 147          void pwm_channel_1_enable(void)
 148          {
 149   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 150   1          STMR_PWMEN |= 0x01 << 1; // ä½¿èƒ½PWM1çš„è¾“å‡º
 151   1      
 152   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
              #else
 155   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 156   1      #endif
 157   1      }
 158          
 159          void pwm_channel_1_disable(void)
 160          {
 161   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 162   1          STMR_PWMEN &= ~(0x01 << 1); // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 163   1      
 164   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_AF_FUNC; //;
                  P05 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
              #else
 168   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
 169   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
C51 COMPILER V9.60.7.0   PWM                                                               01/17/2026 16:42:33 PAGE 4   

 170   1      #endif
 171   1      }
 172          
 173          /**
 174           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£æ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
 175           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
 176           *
 177           * @attention å¦‚æœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
 178           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
 179           *
 180           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty
 181           *
 182           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 183           */
 184          u16 get_pwm_channel_x_adjust_duty(u16 pwm_adjust_duty)
 185          {
 186   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›å€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 187   1          u16 tmp_pwm_duty = (u32)pwm_adjust_duty;
 188   1      
 189   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸç‡ä¸ç¨³å®šã€é£æ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 190   1      
 191   1          // åˆ¤æ–­ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„å ç©ºæ¯” ä¼šä¸ä¼š å¤§äº æ¸©åº¦è¿‡çƒ­ä¹‹åé™åˆ¶çš„å ç©ºæ¯”
 192   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_temp)
 193   1          {
 194   2              tmp_pwm_duty = limited_pwm_duty_due_to_temp;
 195   2          }
 196   1      
 197   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºå‘åŠ¨æœºä¸ç¨³å®šè€Œé™åˆ¶çš„ã€å¯ä»¥è°ƒèŠ‚çš„æœ€å¤§å
             - ç©ºæ¯”
 198   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_unstable_engine)
 199   1          {
 200   2              tmp_pwm_duty = limited_pwm_duty_due_to_unstable_engine;
 201   2          }
 202   1      
 203   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ
             -¯”
 204   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_fan_err)
 205   1          {
 206   2              tmp_pwm_duty = limited_pwm_duty_due_to_fan_err;
 207   2          }
 208   1      
 209   1          return tmp_pwm_duty; // è¿”å›ç»è¿‡çº¿æ§è°ƒå…‰é™åˆ¶ä¹‹åçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 210   1      }
 211          
 212          // æ›´æ–° pwm_channel_0 å¾…è°ƒæ•´çš„å ç©ºæ¯”
 213          // void update_pwm_channel_0_adjust_duty(void)
 214          // {
 215          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 216          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    319    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.60.7.0   PWM                                                               01/17/2026 16:42:33 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
