C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
   6          // ç”±äºŽå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
   8          // ç”±äºŽé£Žæ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä
             -¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   9          volatile u16 limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
  10          
  11          volatile u16 cur_pwm_channel_0_duty;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å ç©
             -ºæ¯”ï¼ˆåªæœ‰é¥æŽ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  12          volatile u16 expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_0 å
             - ç©ºæ¯”
  13          volatile u16 adjust_pwm_channel_0_duty = MAX_PWM_DUTY;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  14          
  15          volatile u16 cur_pwm_channel_1_duty;                          // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”ï¼
             -ˆåªæœ‰é¥æŽ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  16          volatile u16 expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_1 å
             - ç©ºæ¯”
  17          volatile u16 adjust_pwm_channel_1_duty = MAX_PWM_DUTY;        // pwm_channle_1 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  18          
  19          // è®°å½•pwmçš„æ¨¡å¼
  20          volatile u8 pwm_mode = 0;
  21          
  22          #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  23          #define STMR1_PEROID_VAL (SYSCLK / 8000 - 1)
  24          void pwm_init(void)
  25          {
  26   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  27   1      
  28   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  29   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  30   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  31   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  32   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  33   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  34   1      
  35   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿žç»­è®¡æ•°æ¨¡å¼
  36   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  37   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  38   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  39   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  40   1      
  41   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  42   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  43   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  44   1      
  45   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  46   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  47   1          STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 2   

  48   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  49   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  50   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
  51   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  52   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºŽç­‰äºŽæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºŽè¾“å‡º0 )
  53   1      
  54   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿žç»­è®¡æ•°æ¨¡å¼
  55   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  56   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  57   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  58   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  59   1      
  60   1      #if USE_MY_TEST_PIN
                  P0_MD1 &= ~GPIO_P05_MODE_SEL(0x03); // ç”¨å¼€å‘æ¿ä¸Šçš„ p05
                  P0_MD1 |= GPIO_P05_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
              #else
  65   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  66   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  67   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  68   1      #endif //  #if USE_MY_TEST_PIN
  69   1      }
  70          
  71          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  72          void set_pwm_channel_0_duty(u16 channel_duty)
  73          {
  74   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  75   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  76   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  77   1      }
  78          
  79          // è®¾ç½®é€šé“1çš„å ç©ºæ¯”
  80          void set_pwm_channel_1_duty(u16 channel_duty)
  81          {
  82   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  83   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  84   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  85   1      }
  86          
  87          // æ ¹æ®9è„šçš„ç”µåŽ‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡åŽ‹ä¿æŠ¤ï¼‰
  88          // void according_pin9_to_adjust_pin16(void)
  89          // {
  90          //     // å½“9è„šç”µåŽ‹é«˜äºŽ 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºŽæŽ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºŽå…³æœºï
             -¼‰ã€‚
  91          //     // if (adc_val_pin_9 >= 3511)
  92          //     // {
  93          //     //     P14 = 1;
  94          //     // }
  95          //     // else if (adc_val_pin_9 <= 3511 - 40)
  96          //     {
  97          //         P14 = 0;
  98          //     }
  99          // }
 100          
 101          /**
 102           * @brief èŽ·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
 103           *
 104           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 105           */
 106          u8 get_pwm_channel_0_status(void)
 107          {
C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 3   

 108   1          if (STMR_PWMEN & 0x01) // å¦‚æžœpwm0ä½¿èƒ½
 109   1          {
 110   2              return 1;
 111   2          }
 112   1          else // å¦‚æžœpwm0æœªä½¿èƒ½
 113   1          {
 114   2              return 0;
 115   2          }
 116   1      }
 117          
 118          /**
 119           * @brief èŽ·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 120           *
 121           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 122           */
 123          u8 get_pwm_channel_1_status(void)
 124          {
 125   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æžœpwm1ä½¿èƒ½
 126   1          {
 127   2              return 1;
 128   2          }
 129   1          else // å¦‚æžœ pwm æœªä½¿èƒ½
 130   1          {
 131   2              return 0;
 132   2          }
 133   1      }
 134          
 135          void pwm_channel_0_enable(void)
 136          {
 137   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æžä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 138   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 139   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 140   1      }
 141          
 142          void pwm_channel_0_disable(void)
 143          {
 144   1          // ç›´æŽ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›žè¾“å‡ºæ¨¡å¼
 145   1          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 146   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 147   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 148   1      }
 149          
 150          void pwm_channel_1_enable(void)
 151          {
 152   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æžä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 153   1          STMR_PWMEN |= 0x01 << 1; // ä½¿èƒ½PWM1çš„è¾“å‡º
 154   1      
 155   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
              #else
 158   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 159   1      #endif
 160   1      }
 161          
 162          void pwm_channel_1_disable(void)
 163          {
 164   1          // ç›´æŽ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›žè¾“å‡ºæ¨¡å¼
 165   1          STMR_PWMEN &= ~(0x01 << 1); // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 166   1      
 167   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_AF_FUNC; //;
                  P05 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 4   

              #else
 171   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
 172   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 173   1      #endif
 174   1      }
 175          
 176          /**
 177           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æŽ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£Žæ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
 178           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
 179           *
 180           * @attention å¦‚æžœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
 181           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
 182           *
 183           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéžæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty
 184           *
 185           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 186           */
 187          u16 get_pwm_channel_x_adjust_duty(const u16 pwm_adjust_duty)
 188          {
 189   1          // u16 tmp_pwm_duty = pwm_adjust_duty;
 190   1      
 191   1      #if 1
 192   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›žå€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 193   1          u16 tmp_pwm_duty = pwm_adjust_duty;
 194   1          u16 limited_pwm_duty_val; // ç”±åŽç»­çš„è®¡ç®—æ¥èµ‹å€¼
 195   1      
 196   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸçŽ‡ä¸ç¨³å®šã€é£Žæ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 197   1      
 198   1          // åˆ¤æ–­å ç©ºæ¯”ä¼šä¸ä¼š å¤§äºŽ æ¸©åº¦è¿‡çƒ­ä¹‹åŽé™åˆ¶çš„å ç©ºæ¯”
 199   1          if (limited_pwm_duty_due_to_temp != MAX_PWM_DUTY)
 200   1          {
 201   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_temp / MAX_PWM_DUTY);
 202   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 203   2              {
 204   3                  tmp_pwm_duty = limited_pwm_duty_val;
 205   3              }
 206   2          }
 207   1      
 208   1          if (limited_pwm_duty_due_to_unstable_engine != MAX_PWM_DUTY)
 209   1          {
 210   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_unstable_engine / MAX_
             -PWM_DUTY);
 211   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 212   2              {
 213   3                  tmp_pwm_duty = limited_pwm_duty_val;
 214   3              }
 215   2          }
 216   1      
 217   1          if (limited_pwm_duty_due_to_fan_err != MAX_PWM_DUTY)
 218   1          {
 219   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_fan_err / MAX_PWM_DUTY
             -);
 220   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 221   2              {
 222   3                  tmp_pwm_duty = limited_pwm_duty_val;
 223   3              }
 224   2          }
 225   1      #endif
 226   1      
 227   1          return tmp_pwm_duty; // è¿”å›žç»è¿‡çº¿æŽ§è°ƒå…‰é™åˆ¶ä¹‹åŽçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 5   

 228   1      }
 229          
 230          // æ›´æ–° pwm_channel_0 å¾…è°ƒæ•´çš„å ç©ºæ¯”
 231          // void update_pwm_channel_0_adjust_duty(void)
 232          // {
 233          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 234          // }
 235          
 236          // æ ¹æ® PWM æ¨¡å¼ï¼Œæ‰§è¡Œå¯¹åº”çš„åŠŸèƒ½
 237          void pwm_mode_handle(void)
 238          {
 239   1          switch (pwm_mode)
 240   1          {
 241   2          case PWM_MODE_COLOR_TEMPERATURE_1:
 242   2          {
 243   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_20_PERCENT;
 244   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_80_PERCENT;
 245   3          }
 246   2          break;
 247   2          // ===========================================================
 248   2          case PWM_MODE_COLOR_TEMPERATURE_2:
 249   2          {
 250   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_40_PERCENT;
 251   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_60_PERCENT;
 252   3          }
 253   2          break;
 254   2          // ===========================================================
 255   2          case PWM_MODE_COLOR_TEMPERATURE_3:
 256   2          {
 257   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_80_PERCENT;
 258   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_20_PERCENT;
 259   3          }
 260   2          break;
 261   2          // ===========================================================
 262   2          case PWM_MODE_COLOR_TEMPERATURE_4:
 263   2          {
 264   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_60_PERCENT;
 265   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_40_PERCENT;
 266   3          }
 267   2          break;
 268   2          // ===========================================================
 269   2          case PWM_MODE_PULSE:
 270   2          {
 271   3              // ç›®æ ‡pwmå€¼ä¸å˜ï¼Œè®©å®šæ—¶å™¨æ¥æŽ§åˆ¶é—ªçƒ
 272   3          }
 273   2          break;
 274   2          // ===========================================================
 275   2          case PWM_MODE_COLOR_BLUE:
 276   2          {
 277   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 278   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 279   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_0_PERCENT;
 280   3          }
 281   2          break;
 282   2          // ===========================================================
 283   2          case PWM_MODE_COLOR_CYAN:
 284   2          {
 285   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 286   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 287   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_50_PERCENT;
 288   3          }
 289   2          break;
C51 COMPILER V9.60.7.0   PWM                                                               01/20/2026 15:56:37 PAGE 6   

 290   2          // ===========================================================
 291   2          case PWM_MODE_COLOR_GREEN:
 292   2          {
 293   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 294   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_0_PERCENT;
 295   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 296   3          }
 297   2          break;
 298   2              // ===========================================================
 299   2      
 300   2          default:
 301   2          {
 302   3              return;
 303   3          }
 304   2          break;
 305   2          }
 306   1      
 307   1          // if (expect_adjust_pwm_channel_0_duty == cur_pwm_channel_0_duty &&
 308   1          //     expect_adjust_pwm_channel_1_duty == cur_pwm_channel_1_duty)
 309   1          // {
 310   1          //     P14 = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 311   1          // }
 312   1      
 313   1          // {
 314   1          //     static u16 cnt = 0;
 315   1          //     cnt++;
 316   1          //     if (cnt >= 10000)
 317   1          //     {
 318   1          //         cnt = 0;
 319   1          //         printf("pwm_mode = %bu\n", pwm_mode);
 320   1          //         printf("expect_adjust_pwm_channel_0_duty = %u\n", expect_adjust_pwm_channel_0_duty);
 321   1          //         printf("expect_adjust_pwm_channel_1_duty = %u\n", expect_adjust_pwm_channel_1_duty);
 322   1          //     }
 323   1          // }
 324   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    617    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
