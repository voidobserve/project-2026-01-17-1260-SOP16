C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
   6          // ç”±äºŽå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
   8          // ç”±äºŽé£Žæ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä
             -¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   9          volatile u16 limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
  10          
  11          volatile u16 cur_pwm_channel_0_duty;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å ç©
             -ºæ¯”ï¼ˆåªæœ‰é¥æŽ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  12          volatile u16 expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_0 å
             - ç©ºæ¯”
  13          volatile u16 adjust_pwm_channel_0_duty = MAX_PWM_DUTY;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  14          
  15          volatile u16 cur_pwm_channel_1_duty;                          // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”ï¼
             -ˆåªæœ‰é¥æŽ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  16          volatile u16 expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_1 å
             - ç©ºæ¯”
  17          volatile u16 adjust_pwm_channel_1_duty = MAX_PWM_DUTY;        // pwm_channle_1 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  18          
  19          // è®°å½•pwmçš„æ¨¡å¼
  20          volatile u8 pwm_mode = 0;
  21          
  22          #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  23          #define STMR1_PEROID_VAL (SYSCLK / 8000 - 1)
  24          void pwm_init(void)
  25          {
  26   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  27   1      
  28   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  29   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  30   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  31   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  32   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  33   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  34   1      
  35   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿žç»­è®¡æ•°æ¨¡å¼
  36   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  37   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  38   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  39   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  40   1      
  41   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  42   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  43   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  44   1      
  45   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  46   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  47   1          STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 2   

  48   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  49   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  50   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
  51   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  52   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºŽç­‰äºŽæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºŽè¾“å‡º0 )
  53   1      
  54   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿žç»­è®¡æ•°æ¨¡å¼
  55   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  56   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  57   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  58   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  59   1      
  60   1      #if USE_MY_TEST_PIN
                  P0_MD1 &= ~GPIO_P05_MODE_SEL(0x03); // ç”¨å¼€å‘æ¿ä¸Šçš„ p05
                  P0_MD1 |= GPIO_P05_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
              #else
  65   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  66   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  67   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  68   1      #endif //  #if USE_MY_TEST_PIN
  69   1      }
  70          
  71          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  72          void set_pwm_channel_0_duty(u16 channel_duty)
  73          {
  74   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  75   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  76   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  77   1      }
  78          
  79          // è®¾ç½®é€šé“1çš„å ç©ºæ¯”
  80          void set_pwm_channel_1_duty(u16 channel_duty)
  81          {
  82   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  83   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  84   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  85   1      }
  86          
  87          // æ ¹æ®9è„šçš„ç”µåŽ‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡åŽ‹ä¿æŠ¤ï¼‰
  88          // void according_pin9_to_adjust_pin16(void)
  89          // {
  90          //     // å½“9è„šç”µåŽ‹é«˜äºŽ 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºŽæŽ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºŽå…³æœºï
             -¼‰ã€‚
  91          //     // if (adc_val_pin_9 >= 3511)
  92          //     // {
  93          //     //     P14 = 1;
  94          //     // }
  95          //     // else if (adc_val_pin_9 <= 3511 - 40)
  96          //     {
  97          //         P14 = 0;
  98          //     }
  99          // }
 100          
 101          /**
 102           * @brief èŽ·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
 103           *
 104           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 105           */
 106          u8 get_pwm_channel_0_status(void)
 107          {
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 3   

 108   1          if (STMR_PWMEN & 0x01) // å¦‚æžœpwm0ä½¿èƒ½
 109   1          {
 110   2              return 1;
 111   2          }
 112   1          else // å¦‚æžœpwm0æœªä½¿èƒ½
 113   1          {
 114   2              return 0;
 115   2          }
 116   1      }
 117          
 118          /**
 119           * @brief èŽ·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 120           *
 121           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 122           */
 123          u8 get_pwm_channel_1_status(void)
 124          {
 125   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æžœpwm1ä½¿èƒ½
 126   1          {
 127   2              return 1;
 128   2          }
 129   1          else // å¦‚æžœ pwm æœªä½¿èƒ½
 130   1          {
 131   2              return 0;
 132   2          }
 133   1      }
 134          
 135          void pwm_channel_0_enable(void)
 136          {
 137   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æžä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 138   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 139   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 140   1      }
 141          
 142          void pwm_channel_0_disable(void)
 143          {
 144   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 145   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 146   1      
 147   1          // ç›´æŽ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›žè¾“å‡ºæ¨¡å¼
 148   1          STMR_PWMEN &= ~0x01; // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 149   1      }
 150          
 151          void pwm_channel_1_enable(void)
 152          {
 153   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æžä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 154   1          STMR_PWMEN |= 0x01 << 1; // ä½¿èƒ½PWM1çš„è¾“å‡º
 155   1      
 156   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
              #else
 159   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 160   1      #endif
 161   1      }
 162          
 163          void pwm_channel_1_disable(void)
 164          {
 165   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_AF_FUNC; //;
                  P05 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
              #else
 169   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 4   

 170   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 171   1      #endif
 172   1      
 173   1          // ç›´æŽ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›žè¾“å‡ºæ¨¡å¼
 174   1          STMR_PWMEN &= ~(0x01 << 1); // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 175   1      }
 176          
 177          /**
 178           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æŽ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£Žæ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
 179           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
 180           *
 181           * @attention å¦‚æžœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
 182           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
 183           *
 184           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéžæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty
 185           *
 186           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 187           */
 188          u16 get_pwm_channel_x_adjust_duty(const u16 pwm_adjust_duty)
 189          {
 190   1          // u16 tmp_pwm_duty = pwm_adjust_duty;
 191   1      
 192   1      #if 1
 193   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›žå€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 194   1          u16 tmp_pwm_duty = pwm_adjust_duty;
 195   1          u16 limited_pwm_duty_val; // ç”±åŽç»­çš„è®¡ç®—æ¥èµ‹å€¼
 196   1      
 197   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸçŽ‡ä¸ç¨³å®šã€é£Žæ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 198   1      
 199   1          // åˆ¤æ–­å ç©ºæ¯”ä¼šä¸ä¼š å¤§äºŽ æ¸©åº¦è¿‡çƒ­ä¹‹åŽé™åˆ¶çš„å ç©ºæ¯”
 200   1          if (limited_pwm_duty_due_to_temp != MAX_PWM_DUTY)
 201   1          {
 202   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_temp / MAX_PWM_DUTY);
 203   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 204   2              {
 205   3                  tmp_pwm_duty = limited_pwm_duty_val;
 206   3              }
 207   2          }
 208   1      
 209   1          if (limited_pwm_duty_due_to_unstable_engine != MAX_PWM_DUTY)
 210   1          {
 211   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_unstable_engine / MAX_
             -PWM_DUTY);
 212   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 213   2              {
 214   3                  tmp_pwm_duty = limited_pwm_duty_val;
 215   3              }
 216   2          }
 217   1      
 218   1          if (limited_pwm_duty_due_to_fan_err != MAX_PWM_DUTY)
 219   1          {
 220   2              limited_pwm_duty_val = (u16)((u32)pwm_adjust_duty * limited_pwm_duty_due_to_fan_err / MAX_PWM_DUTY
             -);
 221   2              if (tmp_pwm_duty >= limited_pwm_duty_val)
 222   2              {
 223   3                  tmp_pwm_duty = limited_pwm_duty_val;
 224   3              }
 225   2          }
 226   1      #endif
 227   1      
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 5   

 228   1          return tmp_pwm_duty; // è¿”å›žç»è¿‡çº¿æŽ§è°ƒå…‰é™åˆ¶ä¹‹åŽçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 229   1      }
 230          
 231          // æ›´æ–° pwm_channel_0 å¾…è°ƒæ•´çš„å ç©ºæ¯”
 232          // void update_pwm_channel_0_adjust_duty(void)
 233          // {
 234          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 235          // }
 236          
 237          // æ ¹æ® PWM æ¨¡å¼ï¼Œæ‰§è¡Œå¯¹åº”çš„åŠŸèƒ½
 238          void pwm_mode_handle(void)
 239          {
 240   1          switch (pwm_mode)
 241   1          {
 242   2          case PWM_MODE_COLOR_TEMPERATURE_1:
 243   2          {
 244   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_20_PERCENT;
 245   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_80_PERCENT;
 246   3          }
 247   2          break;
 248   2          // ===========================================================
 249   2          case PWM_MODE_COLOR_TEMPERATURE_2:
 250   2          {
 251   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_40_PERCENT;
 252   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_60_PERCENT;
 253   3          }
 254   2          break;
 255   2          // ===========================================================
 256   2          case PWM_MODE_COLOR_TEMPERATURE_3:
 257   2          {
 258   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_60_PERCENT;
 259   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_40_PERCENT;
 260   3          }
 261   2          break;
 262   2          // ===========================================================
 263   2          case PWM_MODE_COLOR_TEMPERATURE_4:
 264   2          {
 265   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_80_PERCENT;
 266   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_20_PERCENT;
 267   3          }
 268   2          break;
 269   2          // ===========================================================
 270   2          case PWM_MODE_COLOR_BLUE:
 271   2          {
 272   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 273   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 274   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_0_PERCENT;
 275   3          }
 276   2          break;
 277   2          // ===========================================================
 278   2          case PWM_MODE_COLOR_CYAN:
 279   2          {
 280   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 281   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 282   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_50_PERCENT;
 283   3          }
 284   2          break;
 285   2          // ===========================================================
 286   2          case PWM_MODE_COLOR_GREEN:
 287   2          {
 288   3              // èŽ·å–æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 289   3              expect_adjust_pwm_channel_0_duty = PWM_DUTY_0_PERCENT;
C51 COMPILER V9.60.7.0   PWM                                                               01/29/2026 16:51:30 PAGE 6   

 290   3              expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 291   3          }
 292   2          break;
 293   2              // ===========================================================
 294   2          case PWM_MODE_PULSE_1:
 295   2          case PWM_MODE_PULSE_2:
 296   2          case PWM_MODE_PULSE_3:
 297   2          case PWM_MODE_PULSE_4:
 298   2          case PWM_MODE_PULSE_5:
 299   2          {
 300   3              // ä¸æ”¹å˜å ç©ºæ¯”ï¼Œç”±å®šæ—¶å™¨è°ƒèŠ‚ é¢‘é—ªåŠ¨ç”»
 301   3          }
 302   2          break;
 303   2              // ===========================================================
 304   2          default:
 305   2          {
 306   3              return;
 307   3          }
 308   2          break;
 309   2          }
 310   1      
 311   1          // if (expect_adjust_pwm_channel_0_duty == cur_pwm_channel_0_duty &&
 312   1          //     expect_adjust_pwm_channel_1_duty == cur_pwm_channel_1_duty)
 313   1          // {
 314   1          //     P14 = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 315   1          // }
 316   1      
 317   1          // {
 318   1          //     static u16 cnt = 0;
 319   1          //     cnt++;
 320   1          //     if (cnt >= 10000)
 321   1          //     {
 322   1          //         cnt = 0;
 323   1          //         printf("pwm_mode = %bu\n", pwm_mode);
 324   1          //         printf("expect_adjust_pwm_channel_0_duty = %u\n", expect_adjust_pwm_channel_0_duty);
 325   1          //         printf("expect_adjust_pwm_channel_1_duty = %u\n", expect_adjust_pwm_channel_1_duty);
 326   1          //     }
 327   1          // }
 328   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    614    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
