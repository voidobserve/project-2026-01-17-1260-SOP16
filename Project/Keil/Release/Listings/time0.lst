C51 COMPILER V9.60.7.0   TIME0                                                             01/20/2026 15:56:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIME0
OBJECT MODULE PLACED IN .\Release\Objects\time0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\time0.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) INCD
                    -IR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\time0.lst) OBJECT(.\Relea
                    -se\Objects\time0.obj)

line level    source

   1          #include "time0.h"
   2          #include "power_on.h"
   3          
   4          // static volatile u8 cnt_during_power_on = 0;       // 开机缓启动，调节pwm占空比时，使用
             -的计数值
   5          
   6          /**
   7           * @brief 配置定时器TMR0
   8           */
   9          void tmr0_config(void)
  10          {
  11   1          __EnableIRQ(TMR0_IRQn); // 使能timer0中断
  12   1          IE_EA = 1;              // 使能总中断
  13   1      
  14   1      #define PEROID_VAL (SYSCLK / 128 / 1000 - 1) // 周期值=系统时钟/分频/频率 - 1
  15   1          // 设置timer0的计数功能，配置一个频率为1kHz的中断
  16   1          TMR_ALLCON = TMR0_CNT_CLR(0x1);                        // 清除计数值
  17   1          TMR0_PRH = TMR_PERIOD_VAL_H((PEROID_VAL >> 8) & 0xFF); // 周期值
  18   1          TMR0_PRL = TMR_PERIOD_VAL_L((PEROID_VAL >> 0) & 0xFF);
  19   1          TMR0_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // 计数等于周期时
             -许发生中断
  20   1          TMR0_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // 选择系统时钟，1
             -28分频，计数模式
  21   1      }
  22          
  23          // /**
  24          //  * @brief 开启定时器TMR0，开始计时
  25          //  */
  26          // void tmr0_enable(void)
  27          // {
  28          //     // 重新给TMR0配置时钟
  29          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  30          //     TMR0_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟（约21MH
             -z）
  31          
  32          //     __EnableIRQ(TMR0_IRQn); // 使能中断
  33          //     IE_EA = 1;              // 打开总中断
  34          // }
  35          
  36          // /**
  37          //  * @brief 关闭定时器0，清空计数值
  38          //  */
  39          // void tmr0_disable(void)
  40          // {
  41          //     // 不给定时器提供时钟，让它停止计数
  42          //     TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  43          //     TMR0_CONL |= TMR_SOURCE_SEL(0x05);    // 配置定时器的时钟源，不用任何时钟
  44          
  45          //     // 清除定时器的计数值
  46          //     TMR0_CNTL = 0;
  47          //     TMR0_CNTH = 0;
  48          
  49          //     __DisableIRQ(TMR0_IRQn); // 关闭中断（不使能中断）
C51 COMPILER V9.60.7.0   TIME0                                                             01/20/2026 15:56:37 PAGE 2   

  50          // }
  51          
  52          // extern void fun(void);
  53          // 定时器TMR0中断服务函数
  54          void TIMR0_IRQHandler(void) interrupt TMR0_IRQn
  55          {
  56   1          // 进入中断设置IP，不可删除
  57   1          __IRQnIPnPush(TMR0_IRQn);
  58   1      
  59   1          // ---------------- 用户函数处理 -------------------
  60   1      
  61   1          // 周期中断
  62   1          if (TMR0_CONH & TMR_PRD_PND(0x1))
  63   1          {
  64   2              TMR0_CONH |= TMR_PRD_PND(0x1); // 清除pending
  65   2      
  66   2              // cnt_during_power_on++;
  67   2              // if (cnt_during_power_on >= 13) // 13ms
  68   2              // {
  69   2              //     cnt_during_power_on = 0;
  70   2              //     flag_time_comes_during_power_on = 1; // 开机缓启动期间，控制每次调节PWM占空
             -比的时间
  71   2              // }
  72   2      
  73   2              flag_time_comes_during_power_on = 1; // 开机缓启动期间，控制每次调节PWM占空比的
             -间
  74   2      
  75   2              if (rf_key_para.cur_scan_times < 255)
  76   2              {
  77   3                  rf_key_para.cur_scan_times++; // 用于433遥控器按键扫描
  78   3              }
  79   2      
  80   2              { // 风扇状态检测，累计一段时间后更新状态
  81   3                  static u16 fan_normal_cnt = 0;
  82   3                  static u16 fan_err_cnt = 0;
  83   3      
  84   3                  if (flag_tim_scan_fan_is_err) // 如果检测到了风扇异常
  85   3                  {
  86   4                      fan_err_cnt++;
  87   4                      fan_normal_cnt = 0;
  88   4      
  89   4                      if (fan_err_cnt >= FAN_SCAN_TIMES_WHEN_ERR)
  90   4                      {
  91   5                          fan_err_cnt = 0;
  92   5                          cur_fan_status = FAN_STATUS_ERROR;
  93   5                      }
  94   4                  }
  95   3                  else
  96   3                  {
  97   4                      fan_normal_cnt++;
  98   4                      fan_err_cnt = 0;
  99   4      
 100   4                      if (fan_normal_cnt >= FAN_SCAN_TIMES_WHEN_NORMAL)
 101   4                      {
 102   5                          fan_normal_cnt = 0;
 103   5                          cur_fan_status = FAN_STATUS_NORMAL;
 104   5                      }
 105   4                  }
 106   3              } // 风扇状态检测，累计一段时间后更新状态      
 107   2          }
 108   1      
 109   1          // 退出中断设置IP，不可删除
C51 COMPILER V9.60.7.0   TIME0                                                             01/20/2026 15:56:37 PAGE 3   

 110   1          __IRQnIPnPop(TMR0_IRQn);
 111   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    175    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
