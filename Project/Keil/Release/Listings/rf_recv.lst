C51 COMPILER V9.60.7.0   RF_RECV                                                           01/29/2026 16:51:31 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\R
                    -elease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
   4          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
   5          
   6          // æŒ‰é”®é”®å€¼ä¸æŒ‰é”®äº‹ä»¶å…³ç³»è¡¨
   7          static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
   8              {RF_433_KEY_VAL_R1C1, RF_433_KEY_EVENT_R1C1_CLICK, RF_433_KEY_EVENT_R1C1_LONG},
   9              {RF_433_KEY_VAL_R1C2, RF_433_KEY_EVENT_R1C2_CLICK, RF_433_KEY_EVENT_R1C2_LONG},
  10              {RF_433_KEY_VAL_R2C1, RF_433_KEY_EVENT_R2C1_CLICK, RF_433_KEY_EVENT_R2C1_LONG},
  11              {RF_433_KEY_VAL_R2C2, RF_433_KEY_EVENT_R2C2_CLICK, RF_433_KEY_EVENT_R2C2_LONG},
  12          
  13              {RF_433_KEY_VAL_R3C1, RF_433_KEY_EVENT_R3C1_CLICK, RF_433_KEY_EVENT_R3C1_LONG},
  14              {RF_433_KEY_VAL_R3C2, RF_433_KEY_EVENT_R3C2_CLICK, RF_433_KEY_EVENT_R3C2_LONG},
  15              {RF_433_KEY_VAL_R4C1, RF_433_KEY_EVENT_R4C1_CLICK, RF_433_KEY_EVENT_R4C1_LONG},
  16              {RF_433_KEY_VAL_R4C2, RF_433_KEY_EVENT_R4C2_CLICK, RF_433_KEY_EVENT_R4C2_LONG},
  17          
  18              {RF_433_KEY_VAL_R5C1, RF_433_KEY_EVENT_R5C1_CLICK, RF_433_KEY_EVENT_R5C1_LONG},
  19              {RF_433_KEY_VAL_R5C2, RF_433_KEY_EVENT_R5C2_CLICK, RF_433_KEY_EVENT_R5C2_LONG},
  20              {RF_433_KEY_VAL_R6C1, RF_433_KEY_EVENT_R6C1_CLICK, RF_433_KEY_EVENT_R6C1_LONG},
  21              {RF_433_KEY_VAL_R6C2, RF_433_KEY_EVENT_R6C2_CLICK, RF_433_KEY_EVENT_R6C2_LONG},
  22          
  23          };
  24          
  25          extern u8 rf_key_get_key_id(void);
  26          volatile struct key_driver_para rf_key_para = {
  27              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™
  28          
  29              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
  30              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
  31              NO_KEY,                   // .last_key
  32          
  33              0,                   // .filter_value
  34              0,                   // .filter_cnt
  35              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
  36          
  37              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
  38              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
  39              0,                                                                                              // .pr
             -ess_cnt
  40          
  41              0,                              // .click_cnt
  42              0,                              // .click_delay_cnt
  43              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
  44              NO_KEY,                         // .notify_value
  45              KEY_TYPE_RF,                    // .key_type
  46              rf_key_get_key_id,              // .get_value
  47          
  48              NO_KEY,         // .latest_key_val
  49              KEY_EVENT_NONE, // .latest_key_event
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/29/2026 16:51:31 PAGE 2   

  50          }; // volatile struct key_driver_para rf_key_para
  51          
  52          /**
  53           * @brief è·å– rf é¥æ§å™¨æŒ‰é”®é”®å€¼ï¼Œä¾› key_driver è°ƒç”¨
  54           *          è¿™é‡Œä¸èƒ½åŒºåˆ†é¥æ§å™¨ç±»å‹ï¼Œåªèƒ½è·å–é¥æ§å™¨æŒ‰é”®
  55           *
  56           * @return u8
  57           */
  58          static u8 rf_key_get_key_id(void)
  59          {
  60   1          u8 ret = NO_KEY;
  61   1      
  62   1          if (0 == flag_is_recved_rf_data)
  63   1          {
  64   2              return NO_KEY;
  65   2          }
  66   1      
  67   1          flag_is_recved_rf_data = 0;
  68   1      
  69   1          if ((u8)(rf_data >> 16) != RF_KEY_ADDR_BYTE_1 ||
  70   1              (u8)(rf_data >> 8) != RF_KEY_ADDR_BYTE_2)
  71   1          {
  72   2              return NO_KEY;
  73   2          }
  74   1      
  75   1          ret = (u8)(rf_data & 0xFF); // è·å–ä½8ä½ä½œä¸ºé”®å€¼
  76   1          // printf("rf_data 0x %lx\n", rf_data);
  77   1      
  78   1          // rf_data = 0;    // æ¥æ”¶å®Œæˆåï¼Œæ¸…é™¤æ¥æ”¶åˆ°çš„æ•°æ®
  79   1          return (u8)ret; // ç›´æ¥è·å–é”®å€¼
  80   1      }
  81          
  82          /**
  83           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
  84           *
  85           * @param key_val æŒ‰é”®é”®å€¼
  86           * @param key_event åœ¨ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
  87           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_433_KEY_
             -EVENT_NONE
  88           */
  89          static u8 rf_key_get_event(const u8 key_val, const u8 key_event)
  90          {
  91   1          volatile u8 ret_key_event = RF_433_KEY_EVENT_NONE;
  92   1          u8 key_event_index = 0;
  93   1          u8 i = 0;
  94   1      
  95   1          // if (key_event != KEY_EVENT_NONE)
  96   1          // {
  97   1          //     printf("key_val %bu, key_event %bu\n", key_val, key_event);
  98   1          // }
  99   1      
 100   1          if (key_event == KEY_EVENT_CLICK)
 101   1          {
 102   2              key_event_index = 1;
 103   2          }
 104   1          else if (key_event == KEY_EVENT_LONG)
 105   1          {
 106   2              key_event_index = 2;
 107   2          }
 108   1          else
 109   1          {
 110   2              return RF_433_KEY_EVENT_NONE;
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/29/2026 16:51:31 PAGE 3   

 111   2          }
 112   1      
 113   1          for (i = 0; i < ARRAY_SIZE(rf_key_event_table); i++)
 114   1          {
 115   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 116   2              if (key_val == rf_key_event_table[i][0])
 117   2              {
 118   3                  ret_key_event = rf_key_event_table[i][key_event_index];
 119   3                  break;
 120   3              }
 121   2          }
 122   1      
 123   1          return ret_key_event;
 124   1      }
 125          
 126          //  å‡½æ•°å†…éƒ¨ä¼šåšé¥æ§å™¨ç±»å‹åŒºåˆ†
 127          void rf_key_handle(void)
 128          {
 129   1          u8 rf_key_event = RF_433_KEY_EVENT_NONE;
 130   1      
 131   1          // å¦‚æœæ˜¯æ— æ•ˆçš„æŒ‰é”®ä¿¡æ¯ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 132   1          if (rf_key_para.latest_key_val == NO_KEY)
 133   1          {
 134   2              return;
 135   2          }
 136   1      #if 1
 137   1      
 138   1          rf_key_event = rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 139   1      
 140   1          // rf_key_para.latest_key_val = NO_KEY;
 141   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 142   1      
 143   1          // printf("rf event %bu\n", rf_key_event);
 144   1      
 145   1          switch (rf_key_event)
 146   1          {
 147   2          case RF_433_KEY_EVENT_R1C1_CLICK:
 148   2          case RF_433_KEY_EVENT_R1C1_LONG:
 149   2          {
 150   3              // printf("r1c1\n");
 151   3              pwm_mode = PWM_MODE_PULSE_1;
 152   3          }
 153   2          break;
 154   2          // =====================================================
 155   2          case RF_433_KEY_EVENT_R1C2_CLICK:
 156   2          case RF_433_KEY_EVENT_R1C2_LONG:
 157   2          {
 158   3              // printf("r1c2\n");
 159   3              pwm_mode = PWM_MODE_PULSE_2;
 160   3          }
 161   2          break;
 162   2          // =====================================================
 163   2          case RF_433_KEY_EVENT_R2C1_CLICK:
 164   2          case RF_433_KEY_EVENT_R2C1_LONG:
 165   2          {
 166   3              // printf("r2c1\n");
 167   3              pwm_mode = PWM_MODE_PULSE_3;
 168   3          }
 169   2          break;
 170   2          // =====================================================
 171   2          case RF_433_KEY_EVENT_R2C2_CLICK:
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/29/2026 16:51:31 PAGE 4   

 172   2          case RF_433_KEY_EVENT_R2C2_LONG:
 173   2          {
 174   3              // printf("r2c2\n");
 175   3              pwm_mode = PWM_MODE_PULSE_4;
 176   3          }
 177   2          break;
 178   2              // =====================================================
 179   2          case RF_433_KEY_EVENT_R3C1_CLICK:
 180   2          case RF_433_KEY_EVENT_R3C1_LONG:
 181   2          {
 182   3              // printf("r3c1\n");
 183   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_1;
 184   3          }
 185   2          break;
 186   2          // =====================================================
 187   2          case RF_433_KEY_EVENT_R3C2_CLICK:
 188   2          case RF_433_KEY_EVENT_R3C2_LONG:
 189   2          {
 190   3              // printf("r3c2\n");
 191   3              pwm_mode = PWM_MODE_PULSE_5;
 192   3          }
 193   2          break;
 194   2          // =====================================================
 195   2          case RF_433_KEY_EVENT_R4C1_CLICK:
 196   2          case RF_433_KEY_EVENT_R4C1_LONG:
 197   2          {
 198   3              // printf("r4c1\n");
 199   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_2;
 200   3          }
 201   2          break;
 202   2              // =====================================================
 203   2          case RF_433_KEY_EVENT_R4C2_CLICK:
 204   2          case RF_433_KEY_EVENT_R4C2_LONG:
 205   2          {
 206   3              // printf("r4c2\n");
 207   3              pwm_mode = PWM_MODE_COLOR_BLUE;
 208   3          }
 209   2          break;
 210   2              // =====================================================
 211   2          case RF_433_KEY_EVENT_R5C1_CLICK:
 212   2          case RF_433_KEY_EVENT_R5C1_LONG:
 213   2          {
 214   3              // printf("r5c1\n");
 215   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_3;
 216   3          }
 217   2          break;
 218   2              // =====================================================
 219   2          case RF_433_KEY_EVENT_R5C2_CLICK:
 220   2          case RF_433_KEY_EVENT_R5C2_LONG:
 221   2          {
 222   3              // printf("r5c2\n");
 223   3              pwm_mode = PWM_MODE_COLOR_CYAN;
 224   3          }
 225   2          break;
 226   2              // =====================================================
 227   2          case RF_433_KEY_EVENT_R6C1_CLICK:
 228   2          case RF_433_KEY_EVENT_R6C1_LONG:
 229   2          {
 230   3              // printf("r6c1\n");
 231   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_4;
 232   3          }
 233   2          break;
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/29/2026 16:51:31 PAGE 5   

 234   2              // =====================================================
 235   2          case RF_433_KEY_EVENT_R6C2_CLICK:
 236   2          case RF_433_KEY_EVENT_R6C2_LONG:
 237   2          {
 238   3              // printf("r6c2\n");
 239   3              pwm_mode = PWM_MODE_COLOR_GREEN;
 240   3          }
 241   2          break;
 242   2              // =====================================================
 243   2      
 244   2          default:
 245   2          {
 246   3              return;
 247   3          }
 248   2          break;
 249   2          }
 250   1      
 251   1          // æ ¹æ®å¯¹åº”çš„æ¨¡å¼ï¼Œç«‹å³è®¾ç½® pwm å ç©ºæ¯”
 252   1          pwm_mode_handle();
 253   1          adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 254   1          adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 255   1          cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty;
 256   1          cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty;
 257   1          set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 258   1          set_pwm_channel_1_duty(cur_pwm_channel_1_duty);
 259   1      
 260   1      #endif
 261   1      }
 262          
 263          void rf_recv_init(void)
 264          {
 265   1      // MY_DEBUG:
 266   1      #if USE_MY_TEST_PIN // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
              
                  P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
                  P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
              
              #else // å®é™…ç”¨åˆ°çš„ã€éæµ‹è¯•æ—¶ä½¿ç”¨çš„rfä¿¡å·æ£€æµ‹å¼•è„šï¼š
 272   1      
 273   1          P0_PU |= GPIO_P03_PULL_UP(0x01);      // ä¸Šæ‹‰
 274   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 275   1      
 276   1      #endif // #if USE_MY_TEST_PIN
 277   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    457    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     59       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
