C51 COMPILER V9.60.7.0   RF_RECV                                                           01/19/2026 17:23:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\R
                    -elease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
   4          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
   5          
   6          // æŒ‰é”®é”®å€¼ä¸æŒ‰é”®äº‹ä»¶å…³ç³»è¡¨
   7          static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
   8              {RF_433_KEY_VAL_R1C1, RF_433_KEY_EVENT_R1C1_CLICK, RF_433_KEY_EVENT_R1C1_LONG},
   9              {RF_433_KEY_VAL_R1C2, RF_433_KEY_EVENT_R1C2_CLICK, RF_433_KEY_EVENT_R1C2_LONG},
  10              {RF_433_KEY_VAL_R2C1, RF_433_KEY_EVENT_R2C1_CLICK, RF_433_KEY_EVENT_R2C1_LONG},
  11              {RF_433_KEY_VAL_R2C2, RF_433_KEY_EVENT_R2C2_CLICK, RF_433_KEY_EVENT_R2C2_LONG},
  12          
  13              {RF_433_KEY_VAL_R3C1, RF_433_KEY_EVENT_R3C1_CLICK, RF_433_KEY_EVENT_R3C1_LONG},
  14              {RF_433_KEY_VAL_R3C2, RF_433_KEY_EVENT_R3C2_CLICK, RF_433_KEY_EVENT_R3C2_LONG},
  15              {RF_433_KEY_VAL_R4C1, RF_433_KEY_EVENT_R4C1_CLICK, RF_433_KEY_EVENT_R4C1_LONG},
  16              {RF_433_KEY_VAL_R4C2, RF_433_KEY_EVENT_R4C2_CLICK, RF_433_KEY_EVENT_R4C2_LONG},
  17          
  18          };
  19          
  20          extern u8 rf_key_get_key_id(void);
  21          volatile struct key_driver_para rf_key_para = {
  22              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™
  23          
  24              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
  25              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
  26              NO_KEY,                   // .last_key
  27          
  28              0,                   // .filter_value
  29              0,                   // .filter_cnt
  30              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
  31          
  32              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
  33              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
  34              0,                                                                                              // .pr
             -ess_cnt
  35          
  36              0,                              // .click_cnt
  37              0,                              // .click_delay_cnt
  38              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
  39              NO_KEY,                         // .notify_value
  40              KEY_TYPE_RF,                    // .key_type
  41              rf_key_get_key_id,              // .get_value
  42          
  43              NO_KEY,         // .latest_key_val
  44              KEY_EVENT_NONE, // .latest_key_event
  45          }; // volatile struct key_driver_para rf_key_para
  46          
  47          /**
  48           * @brief è·å– rf é¥æ§å™¨æŒ‰é”®é”®å€¼ï¼Œä¾› key_driver è°ƒç”¨
  49           *          è¿™é‡Œä¸èƒ½åŒºåˆ†é¥æ§å™¨ç±»å‹ï¼Œåªèƒ½è·å–é¥æ§å™¨æŒ‰é”®
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/19/2026 17:23:13 PAGE 2   

  50           *
  51           * @return u8
  52           */
  53          static u8 rf_key_get_key_id(void)
  54          {
  55   1          u8 ret = NO_KEY;
  56   1      
  57   1          if (0 == flag_is_recved_rf_data)
  58   1          {
  59   2              return NO_KEY;
  60   2          }
  61   1      
  62   1          flag_is_recved_rf_data = 0;
  63   1      
  64   1          if ((u8)(rf_data >> 16) != RF_KEY_ADDR_BYTE_1 ||
  65   1              (u8)(rf_data >> 8) != RF_KEY_ADDR_BYTE_2)
  66   1          {
  67   2              return NO_KEY;
  68   2          }
  69   1      
  70   1          ret = (u8)(rf_data & 0xFF); // è·å–ä½8ä½ä½œä¸ºé”®å€¼
  71   1          // printf("rf_data 0x %lx\n", rf_data);
  72   1      
  73   1          // rf_data = 0;    // æ¥æ”¶å®Œæˆåï¼Œæ¸…é™¤æ¥æ”¶åˆ°çš„æ•°æ®
  74   1          return (u8)ret; // ç›´æ¥è·å–é”®å€¼
  75   1      }
  76          
  77          /**
  78           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
  79           *
  80           * @param key_val æŒ‰é”®é”®å€¼
  81           * @param key_event åœ¨ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
  82           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_433_KEY_
             -EVENT_NONE
  83           */
  84          static u8 rf_key_get_event(const u8 key_val, const u8 key_event)
  85          {
  86   1          volatile u8 ret_key_event = RF_433_KEY_EVENT_NONE;
  87   1          u8 key_event_index = 0;
  88   1          u8 i = 0;
  89   1      
  90   1          // if (key_event != KEY_EVENT_NONE)
  91   1          // {
  92   1          //     printf("key_val %bu, key_event %bu\n", key_val, key_event);
  93   1          // }
  94   1      
  95   1          if (key_event == KEY_EVENT_CLICK)
  96   1          {
  97   2              key_event_index = 1;
  98   2          }
  99   1          else if (key_event == KEY_EVENT_LONG)
 100   1          {
 101   2              key_event_index = 2;
 102   2          }
 103   1          else
 104   1          {
 105   2              return RF_433_KEY_EVENT_NONE;
 106   2          }
 107   1      
 108   1          for (i = 0; i < ARRAY_SIZE(rf_key_event_table); i++)
 109   1          {
 110   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/19/2026 17:23:13 PAGE 3   

             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 111   2              if (key_val == rf_key_event_table[i][0])
 112   2              {
 113   3                  ret_key_event = rf_key_event_table[i][key_event_index];
 114   3                  break;
 115   3              }
 116   2          }
 117   1      
 118   1          return ret_key_event;
 119   1      }
 120          
 121          //  å‡½æ•°å†…éƒ¨ä¼šåšé¥æ§å™¨ç±»å‹åŒºåˆ†
 122          void rf_key_handle(void)
 123          {
 124   1          u8 rf_key_event = RF_433_KEY_EVENT_NONE;
 125   1      
 126   1          // å¦‚æœæ˜¯æ— æ•ˆçš„æŒ‰é”®ä¿¡æ¯ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 127   1          if (rf_key_para.latest_key_val == NO_KEY)
 128   1          {
 129   2              return;
 130   2          }
 131   1      #if 1
 132   1      
 133   1          rf_key_event = rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 134   1      
 135   1          // rf_key_para.latest_key_val = NO_KEY;
 136   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 137   1      
 138   1          // printf("rf event %bu\n", rf_key_event);
 139   1      
 140   1          switch (rf_key_event)
 141   1          {
 142   2          case RF_433_KEY_EVENT_R1C1_CLICK:
 143   2          case RF_433_KEY_EVENT_R1C1_LONG:
 144   2          {
 145   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_1; 
 146   3          }
 147   2          break;
 148   2          // =====================================================
 149   2          case RF_433_KEY_EVENT_R1C2_CLICK:
 150   2          case RF_433_KEY_EVENT_R1C2_LONG:
 151   2          {
 152   3              pwm_mode = PWM_MODE_PULSE; 
 153   3          }
 154   2          break;
 155   2          // =====================================================
 156   2          case RF_433_KEY_EVENT_R2C1_CLICK:
 157   2          case RF_433_KEY_EVENT_R2C1_LONG:
 158   2          {
 159   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_2; 
 160   3          }
 161   2          break;
 162   2          // =====================================================
 163   2          case RF_433_KEY_EVENT_R2C2_CLICK:
 164   2          case RF_433_KEY_EVENT_R2C2_LONG:
 165   2          {
 166   3              pwm_mode = PWM_MODE_COLOR_BLUE; 
 167   3          }
 168   2          break;
 169   2              // =====================================================
 170   2          case RF_433_KEY_EVENT_R3C1_CLICK:
 171   2          case RF_433_KEY_EVENT_R3C1_LONG:
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/19/2026 17:23:13 PAGE 4   

 172   2          {
 173   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_3; 
 174   3          }
 175   2          break;
 176   2          // =====================================================
 177   2          case RF_433_KEY_EVENT_R3C2_CLICK:
 178   2          case RF_433_KEY_EVENT_R3C2_LONG:
 179   2          {
 180   3              pwm_mode = PWM_MODE_COLOR_CYAN; 
 181   3          }
 182   2          break;
 183   2          // =====================================================
 184   2          case RF_433_KEY_EVENT_R4C1_CLICK:
 185   2          case RF_433_KEY_EVENT_R4C1_LONG:
 186   2          {
 187   3              pwm_mode = PWM_MODE_COLOR_TEMPERATURE_4; 
 188   3          }
 189   2          break; 
 190   2              // =====================================================
 191   2          case RF_433_KEY_EVENT_R4C2_CLICK: 
 192   2          case RF_433_KEY_EVENT_R4C2_LONG:
 193   2          { 
 194   3              pwm_mode = PWM_MODE_COLOR_GREEN; 
 195   3          }
 196   2          break;
 197   2              // =====================================================
 198   2      
 199   2          default:
 200   2          {
 201   3              return;
 202   3          }
 203   2              break;
 204   2          }
 205   1      
 206   1          // æ ¹æ®å¯¹åº”çš„æ¨¡å¼ï¼Œç«‹å³è®¾ç½® pwm å ç©ºæ¯”
 207   1          pwm_mode_handle();
 208   1          adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 209   1          adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 210   1          cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty;
 211   1          cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty;
 212   1          set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 213   1          set_pwm_channel_1_duty(cur_pwm_channel_1_duty);
 214   1      
 215   1      #endif
 216   1      }
 217          
 218          void rf_recv_init(void)
 219          {
 220   1      // MY_DEBUG:
 221   1      #if USE_MY_TEST_PIN // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
              
                  P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
                  P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
              
              #else // å®é™…ç”¨åˆ°çš„ã€éæµ‹è¯•æ—¶ä½¿ç”¨çš„rfä¿¡å·æ£€æµ‹å¼•è„šï¼š
 227   1      
 228   1          P0_PU |= GPIO_P03_PULL_UP(0x01);      // ä¸Šæ‹‰
 229   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 230   1      
 231   1      #endif // #if USE_MY_TEST_PIN
 232   1      }

C51 COMPILER V9.60.7.0   RF_RECV                                                           01/19/2026 17:23:13 PAGE 5   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    401    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     47       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
