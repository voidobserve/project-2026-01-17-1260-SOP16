C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\O
                    -bjects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          volatile u16 adc_val_from_engine; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   8          volatile u16 adc_val_from_knob;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   9          volatile u16 adc_val_from_temp;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  10          volatile u16 adc_val_from_fan;    // å­˜æ”¾ æ£€æµ‹é£æ‰‡ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  11          
  12          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
  13          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
  14          
  15          volatile u8 cur_adc_status = ADC_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adcçš„çŠ¶æ€
  16          
  17          volatile u8 adc_engine_val_buff_index = 0;
  18          volatile u16 adc_engine_val_buff[16] = {0xFFFF};
  19          
  20          // adcç›¸å…³çš„å¼•è„šé…ç½®
  21          void adc_pin_config(void)
  22          {
  23   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  24   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  25   1      
  26   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  27   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  28   1      
  29   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  30   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  31   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  32   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  33   1      }
  34          
  35          void adc_config(void)
  36          {
  37   1          __EnableIRQ(ADC_IRQn);    // ä½¿èƒ½ADCä¸­æ–­
  38   1          IE_EA = 1;                // ä½¿èƒ½æ€»ä¸­æ–­
  39   1          ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  40   1                      (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
  41   1          delay_ms(1);              // ç­‰å¾…adcç¨³å®š
  42   1      }
  43          
  44          void adc_channel_sel(u8 adc_sel_pin)
  45          {
  46   1          switch (adc_sel_pin)
  47   1          {
  48   2          case ADC_SEL_PIN_ENGINE:
  49   2          {
  50   3              // ADCé…ç½®
  51   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
  52   3              ADC_ACON1 |= ADC_VREF_SEL(0x5) |                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 2   

             -‰‹å†Œè¯´æœªæ ¡å‡†)
  53   3                           ADC_TEN_SEL(0x3);                           /* å…³é—­æµ‹è¯•ä¿¡å· */
  54   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                            // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  55   3                          ADC_BIAS_EN(0x1) |                           // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  56   3                          ADC_BIAS_SEL(0x1);                           // åç½®ç”µæµï¼š1x
  57   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) |                       // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P2
             -7ï¼‰
  58   3                         ADC_EXT_SEL(0x0);                             // é€‰æ‹©å¤–éƒ¨é€šé“
  59   3          }
  60   2          break; 
  61   2              // ===============================================================================================
             -==
  62   2          case ADC_SEL_PIN_TEMP:
  63   2          {
  64   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹
  65   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
  66   3                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  67   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  68   3                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  69   3                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  70   3      
  71   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  72   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  73   3          }
  74   2          break;
  75   2              // ===============================================================================================
             -==
  76   2          case ADC_SEL_PIN_FAN:
  77   2          {
  78   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  79   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  80   3                           ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å·
  81   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„CMPä
             -½¿èƒ½ä¿¡å·
  82   3                          ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
  83   3                          ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1x
  84   3      
  85   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
  86   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  87   3          }
  88   2          break;
  89   2              // ===============================================================================================
             -==
  90   2          default:
  91   2              break;
  92   2          }
  93   1      
  94   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0
  95   1                      ADC_EN(0x1);        // ä½¿èƒ½adc
  96   1      } 
  97          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
  98          u32 get_voltage_from_pin(void)
  99          {
 100   1          return (u32)adc_val_from_temp * 12 / 10;
 101   1      }
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 3   

 102          
 103          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 104          void temperature_scan(void)
 105          {
 106   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 107   1      
 108   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 109   1          if (TEMP_75_5_MIN == temp_status)
 110   1          {
 111   2              return;
 112   2          }
 113   1      
 114   1          {
 115   2              // è°ƒç”¨è¯¥å‡½æ•°ä¸€å®šæ¬¡æ•°ä¹‹åï¼Œæ‰è¿›è¡Œæ¸©åº¦æ£€æµ‹ï¼Œç¼©çŸ­ä¸»å¾ªç¯çš„æ‰§è¡Œå‘¨æœŸ
 116   2              static volatile u8 cnt = 0;
 117   2              cnt++;
 118   2              if (cnt < 100)
 119   2              {
 120   3                  return;
 121   3              }
 122   2      
 123   2              cnt = 0;
 124   2          }
 125   1      
 126   1          voltage = get_voltage_from_pin(); // å¾—åˆ°çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 127   1      
 128   1      #if USE_MY_DEBUG
                  // printf("PIN-8 voltage: %lu mV\n", voltage);
              #endif // USE_MY_DEBUG
 131   1      
 132   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 133   1          // if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 134   1          if (TEMP_NORMAL == temp_status)
 135   1          {
 136   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 137   2              static volatile u8 cnt = 0;
 138   2              if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°
             -äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 139   2              {
 140   3                  cnt++;
 141   3              }
 142   2              else
 143   2              {
 144   3                  cnt = 0;
 145   3              }
 146   2      
 147   2              if (cnt >= 10)
 148   2              {
 149   3                  cnt = 0;
 150   3                  // æµ‹è¯•çš„æ—¶å€™ï¼Œå¦‚æœå¼•è„šæ‚¬ç©ºï¼Œå¯èƒ½ä¼šæ‰§è¡Œä¸åˆ°è¿™é‡Œï¼š
 151   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦   USER_TO_DO  åœ¨æµ‹è¯•æ—¶ä¼š
             -å±è”½æ‰
 152   3              }
 153   2              else
 154   2              {
 155   3                  temp_status = TEMP_NORMAL;
 156   3              }
 157   2      
 158   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 159   2          }
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 4   

 160   1          else if (TEMP_75 == temp_status)
 161   1          {
 162   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 163   2              static bit tmr1_is_open = 0;
 164   2      
 165   2              if (0 == tmr1_is_open)
 166   2              {
 167   3                  tmr1_is_open = 1;
 168   3                  tmr1_cnt = 0;
 169   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡ä¸€å®šæ—¶é—´
 170   3              }
 171   2      
 172   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 173   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 174   2              {
 175   3                  static volatile u8 cnt = 0;
 176   3      
 177   3                  if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è
             -¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 178   3                  {
 179   4                      cnt++;
 180   4                  }
 181   3                  else
 182   3                  {
 183   4                      cnt = 0;
 184   4                  }
 185   3      
 186   3                  if (cnt >= 10)
 187   3                  {
 188   4                      cnt = 0;
 189   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 190   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 191   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 192   4                      tmr1_is_open = 0;
 193   4                  }
 194   3                  else
 195   3                  {
 196   4                      temp_status = TEMP_75;
 197   4                  }
 198   3      
 199   3                  return;
 200   3              }
 201   2          }
 202   1      }
 203          
 204          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 205          void set_duty(void)
 206          {
 207   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 208   1          if (TEMP_NORMAL == temp_status)
 209   1          {
 210   2              if (flag_is_time_to_check_engine)
 211   2              {
 212   3                  flag_is_time_to_check_engine = 0;
 213   3                  according_pin9_to_adjust_pwm();
 214   3              }
 215   2          }
 216   1          else if (TEMP_75 == temp_status)
 217   1          {
 218   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 219   2          }
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 5   

 220   1          else if (TEMP_75_5_MIN == temp_status)
 221   1          {
 222   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 223   2          }
 224   1      }
 225          
 226          void fan_scan(void)
 227          {
 228   1          u16 adc_val = adc_val_from_fan; // adc_val_from_fan ç”±adcä¸­æ–­è§¦å‘
 229   1      
 230   1          /*
 231   1              1è„šç”µå‹ä½äº4.3Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º25%å ç©ºæ¯”ï¼Œ
 232   1              1è„šç”µå‹é«˜äº4.5Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º100%å ç©ºæ¯”
 233   1          */
 234   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 235   1          {
 236   2              if (adc_val <= ADC_VAL_WHEN_FAN_ERR)
 237   2              {
 238   3                  flag_tim_scan_fan_is_err = 1; // è¡¨ç¤ºé£æ‰‡å¼‚å¸¸ï¼Œè®©å®šæ—¶å™¨ç´¯è®¡æ—¶é—´
 239   3              }
 240   2              else
 241   2              {
 242   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 243   3                  flag_tim_scan_fan_is_err = 0;
 244   3              }
 245   2      
 246   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 247   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 248   2          }
 249   1          else // FAN_STATUS_ERROR == cur_fan_status
 250   1          {
 251   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 252   2              if (adc_val >= ADC_VAL_WHEN_FAN_NORMAL)
 253   2              {
 254   3                  flag_tim_scan_fan_is_err = 0; // è¡¨ç¤ºé£æ‰‡æ­£å¸¸
 255   3              }
 256   2      
 257   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 258   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 259   2          }
 260   1      }
 261          
 262          void ADC_IRQHandler(void) interrupt ADC_IRQn
 263          {
 264   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 265   1          __IRQnIPnPush(ADC_IRQn);
 266   1      
 267   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 268   1       
 269   1      
 270   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 271   1          {
 272   2              volatile u16 adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 273   2              ADC_STA |= ADC_CHAN0_DONE(0x01);                              // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 274   2      
 275   2              if (ADC_STATUS_SEL_ENGINE == cur_adc_status)
 276   2              {
 277   3                  // æ›´æ–°å‘åŠ¨æœºæ£€æµ‹ä¸€ç«¯çš„adå€¼
 278   3      
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 6   

 279   3                  static u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 280   3                  static volatile u32 g_tmpbuff = 0;
 281   3                  static volatile u16 g_adcmax = 0;
 282   3                  static volatile u16 g_adcmin = 0xFFFF;
 283   3      
 284   3                  if (i < 20)
 285   3                  {
 286   4                      i++;
 287   4      
 288   4                      if (i >= 2) // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·å€¼
 289   4                      {
 290   5                          if (adc_val > g_adcmax)
 291   5                              g_adcmax = adc_val; // æœ€å¤§
 292   5                          if (adc_val < g_adcmin)
 293   5                              g_adcmin = adc_val; // æœ€å°
 294   5                          g_tmpbuff += adc_val;
 295   5                      }
 296   4      
 297   4                      if (i < 20)
 298   4                          ADC_CFG0 |= 0x01 << 0; // å¼€å¯adc0è½¬æ¢
 299   4                  }
 300   3      
 301   3                  if (i >= 20)
 302   3                  {
 303   4                      adc_val_from_engine = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 304   4                      cur_adc_status = ADC_STATUS_SEL_ENGINE_DONE;
 305   4      
 306   4                      // é‡æ–°åˆå§‹åŒ–ä½¿ç”¨åˆ°çš„å˜é‡ï¼š
 307   4                      i = 0;
 308   4                      g_adcmax = 0;
 309   4                      g_adcmin = 0xFFFF;
 310   4                      g_tmpbuff = 0;
 311   4                      // printf("1 engine scan done\n");
 312   4                  }
 313   3              } 
 314   2              else if (ADC_STATUS_SEL_GET_TEMP == cur_adc_status)
 315   2              {
 316   3                  // æ›´æ–°çƒ­æ•ç”µé˜»æ£€æµ‹ä¸€ç«¯çš„adå€¼
 317   3                  adc_val_from_temp = adc_val;
 318   3                  // printf("3 temp scan done\n");
 319   3              }
 320   2              else if (ADC_STATUS_SEL_FAN_DETECT == cur_adc_status)
 321   2              {
 322   3                  // æ›´æ–°é£æ‰‡æ£€æµ‹ä¸€ç«¯çš„adå€¼
 323   3                  adc_val_from_fan = adc_val;
 324   3                  // printf("4 fan scan done\n");
 325   3              }
 326   2          }
 327   1      
 328   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 329   1          __IRQnIPnPop(ADC_IRQn);
 330   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    830    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     56       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
C51 COMPILER V9.60.7.0   ADC                                                               01/20/2026 15:56:37 PAGE 7   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
