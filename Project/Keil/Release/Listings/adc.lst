C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          volatile u16 adc_val_from_engine; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   8          volatile u16 adc_val_from_knob;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   9          volatile u16 adc_val_from_temp;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  10          volatile u16 adc_val_from_fan;    // å­˜æ”¾ æ£€æµ‹é£æ‰‡ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  11          
  12          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
  13          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
  14          
  15          volatile u8 cur_adc_status = ADC_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adcçš„çŠ¶æ€
  16          // volatile u8 cur_adc2_status = ADC2_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adc2çš„çŠ¶æ€
  17          
  18          // volatile bit flag_is_pin_9_vol_bounce = 0; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨
  19          
  20          volatile u8 adc_engine_val_buff_index = 0;
  21          volatile u16 adc_engine_val_buff[16] = {0xFFFF};
  22          
  23          // adcç›¸å…³çš„å¼•è„šé…ç½®
  24          void adc_pin_config(void)
  25          {
  26   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  27   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  28   1      
  29   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  30   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  31   1      
  32   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  33   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  34   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  35   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  36   1      
  37   1          // P13 -- èŠ¯ç‰‡çš„1è„šï¼Œé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  38   1          P1_PU &= ~(0x01 << 3);             // å…³é—­ä¸Šæ‹‰
  39   1          P1_PD &= ~(0x01 << 3);             // å…³é—­ä¸‹æ‹‰
  40   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x03); // æ¨¡æ‹ŸIOå·¥ä½œæ¨¡å¼
  41   1      }
  42          
  43          // åˆ‡æ¢adcé‡‡é›†çš„å¼•è„šï¼Œé…ç½®å¥½adc
  44          // å‚æ•°å¯ä»¥é€‰æ‹©ï¼š
  45          // ADC_SEL_PIN_GET_TEMP
  46          // ADC_SEL_PIN_GET_VOL
  47          // void adc_sel_pin(const u8 adc_sel)
  48          // {
  49          //     // åˆ‡æ¢é‡‡é›†å¼•è„šæ—¶ï¼ŒæŠŠä¹‹å‰é‡‡é›†åˆ°çš„adå€¼æ¸…ç©º
  50          //     // adc0_val = 0;
  51          //     static u8 last_adc_sel = 0;
  52          //     if (last_adc_sel == adc_sel)
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 2   

  53          //     {
  54          //         // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€
             -€å‡º
  55          //         return;
  56          //     }
  57          
  58          //     last_adc_sel = adc_sel;
  59          
  60          //     ADC_CFG1 |= (0x0F << 3); // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  61          //     ADC_CFG2 = 0xFF;         // é€šé“0é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
  62          
  63          //     switch (adc_sel)
  64          //     {
  65          //     case ADC_SEL_PIN_GET_TEMP: // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹åº”çš„ç”µå‹çš„å¼•è„šï¼ˆ8è„šï¼‰
  66          
  67          //         // ADCé…ç½®
  68          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  69          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  70          //                      ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  71          //         ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä
             -½¿èƒ½ä¿¡å·
  72          //                     ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
  73          //                     ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  74          
  75          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  76          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  77          
  78          //         break;
  79          
  80          //     case ADC_SEL_PIN_GET_VOL: // æ£€æµ‹å›è·¯ç”µå‹çš„å¼•è„šï¼ˆ9è„šï¼‰
  81          
  82          //         // ADCé…ç½®
  83          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€
             -‰æ‹©çš„å‚è€ƒç”µå‹
  84          //         // ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è
             -€ƒç”µå‹VCCA
  85          //         //              ADC_TEN_SEL(0x3);
  86          //         ADC_ACON1 |= ADC_VREF_SEL(0x5) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ‰‹å†Œè¯´æœªæ ¡å‡†)
  87          //                      ADC_TEN_SEL(0x3);     /* å…³é—­æµ‹è¯•ä¿¡å· */
  88          //         ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  89          //                     ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  90          //                     ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  91          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x17) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
  92          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  93          
  94          //         break;
  95          
  96          //     case ADC_SEL_PIN_P31: // P31ã€7è„šï¼Œæ£€æµ‹æ—‹é’®è°ƒå…‰
  97          
  98          //         // ADCé…ç½®
  99          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 100          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
 101          //                      ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
 102          //         ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
 103          //                     ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 104          //                     ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
 105          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
 106          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 107          
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 3   

 108          //         break;
 109          
 110          //     case ADC_SEL_PIN_FAN_DETECT: // P13 èŠ¯ç‰‡çš„1è„šï¼Œæ£€æµ‹é£æ‰‡æ˜¯å¦å¼‚å¸¸
 111          
 112          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è
             -€ƒç”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 113          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è
             -€ƒç”µå‹VCCA
 114          //                      ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å
             -·
 115          //         ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„C
             -MPä½¿èƒ½ä¿¡å·
 116          //                     ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç
             -”µæµèƒ½ä½¿ä¿¡å·
 117          //                     ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1
             -x
 118          
 119          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
 120          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 121          
 122          //         break;
 123          //     }
 124          
 125          //     ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0è½¬æ¢
 126          //                 ADC_EN(0x1);        // ä½¿èƒ½A/Dè½¬æ¢
 127          //     // delay_ms(1);                    // ç­‰å¾…ADCç¨³å®š
 128          //     // å®˜æ–¹çš„demoä¸­æåˆ°ç­‰å¾…20usä»¥ä¸Š
 129          //     delay((u32)1450 / 2);
 130          //     // delay((u32)1450 / 4);
 131          // }
 132          
 133          void adc_config(void)
 134          {
 135   1      #if 0
                  __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
                  IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
              
                  ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) |   // æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
                                 ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
                                 ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
                  ADC_ACON1 |= ADC_VREF_SEL(0x6) |     // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA ï¼ˆå›ºå®šä½¿ç”¨VCCAï¼Œä¸å»ä¿®æ”
             -¹ï¼‰
                               ADC_TEN_SEL(0x3);       // å…³é—­æµ‹è¯•ä¿¡å·
                  ADC_ACON0 = ADC_CMP_EN(0x1) |        // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
                              ADC_BIAS_EN(0x1) |       // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
                              ADC_BIAS_SEL(0x1);       // åç½®ç”µæµï¼š1x
              
                  ADC_TRGS0 |= (0x07 << 4); // é€šé“ 0DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 1
                  ADC_CHS0 |= (0x01 << 6);  // ä½¿èƒ½ é€šé“ 0DLY åŠŸèƒ½
              
                  ADC_TRGS1 |= (0x07 << 4); // é…ç½®é€šé“ 1DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 
             -1
                  ADC_CHS1 |= (0x01 << 6);  // ä½¿èƒ½é€šé“ 1DLY åŠŸèƒ½
              
                  ADC_TRGS2 |= (0x07 << 4); // é…ç½®é€šé“ 2DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 
             -1
                  ADC_CHS2 |= (0x01 << 6);  // ä½¿èƒ½é€šé“ 2DLY åŠŸèƒ½
              
                  ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
                              (0x01 << 2) | // ADC2 é€šé“ä¸­æ–­ä½¿èƒ½
                              (0x01 << 1) | // ADC1 é€šé“ä¸­æ–­ä½¿èƒ½
                              (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 4   

                  ADC_CFG2 = 0xFF;          // é€šé“0 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
                  ADC_CFG3 = 0xFF;          // é€šé“1 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
                  ADC_CFG4 = 0xFF;          // é€šé“2 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
              
                  adc0_channel_sel();
                  adc1_channel_sel();
                  adc2_channel_sel(ADC_SEL_PIN_NONE);
              
                  ADC_CFG0 |= ADC_CHAN0_EN(0x01) |
                              ADC_CHAN1_EN(0x01) |
                              ADC_CHAN2_EN(0x01) |
                              ADC_EN(0x01); // ä½¿èƒ½adc
              #endif
 174   1      
 175   1          __EnableIRQ(ADC_IRQn);    // ä½¿èƒ½ADCä¸­æ–­
 176   1          IE_EA = 1;                // ä½¿èƒ½æ€»ä¸­æ–­
 177   1          ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
 178   1                      (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
 179   1          delay_ms(1);              // ç­‰å¾…adcç¨³å®š
 180   1      }
 181          
 182          #if 0
              // é…ç½®adc0ï¼Œadc0åªé€‰æ‹©æ£€æµ‹å‘åŠ¨æœºçš„é€šé“
              void adc0_channel_sel(void)
              {
                  ADC_CHS0 &= ~(ADC_EXT_SEL(0x01));  // é€‰æ‹©å¤–éƒ¨é€šé“
                  ADC_CHS0 &= ~(0x1F << 0);          // æ¸…ç©º adc0 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
                  ADC_CHS0 |= ADC_ANALOG_CHAN(0x17); // adc0 é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
              }
              
              // é…ç½®adc1 adc1åªæ£€æµ‹æ—‹é’®è°ƒå…‰çš„é€šé“
              void adc1_channel_sel(void)
              {
                  ADC_CHS1 &= ~(ADC_EXT_SEL(0x01)); // é€‰æ‹©å¤–éƒ¨é€šé“
                  ADC_CHS1 &= ~(0x1F << 0);         // æ¸…ç©º adc1 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
                  ADC_CHS1 = ADC_ANALOG_CHAN(0x19); // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
              }
              #endif
 199          
 200          #if 0
              /**
               * @brief é…ç½®adc2 adc2 è¦æ£€æµ‹æ¸©åº¦ã€é£æ‰‡çŠ¶æ€
               *      åˆ‡æ¢å®Œæˆåï¼Œä¸èƒ½é©¬ä¸Šä½¿ç”¨ï¼Œè¦ç­‰adcç¨³å®š
               */
              void adc2_channel_sel(u8 adc_sel_pin)
              {
              
                  static u8 last_adc_sel = 0;
                  if (last_adc_sel == adc_sel_pin)
                  {
                      // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€€å‡
             -º
                      return;
                  }
              
                  last_adc_sel = adc_sel_pin;
              
                  ADC_CHS2 &= ~(ADC_EXT_SEL(0x01)); // é€‰æ‹©å¤–éƒ¨é€šé“
                  ADC_CHS2 &= ~(0x1F << 0);         // æ¸…ç©º adc2 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
              
                  switch (adc_sel_pin)
                  {
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 5   

                  case ADC_SEL_PIN_GET_TEMP:
                  {
                      ADC_CHS2 |= 0x18 << 0;
                  }
                  break;
                  case ADC_SEL_PIN_FAN_DETECT:
                  {
                      ADC_CHS2 |= 0x0B << 0;
                  }
                  break;
              
                  default:
                      break;
                  }
              }
              #endif
 238          
 239          void adc_channel_sel(u8 adc_sel_pin)
 240          {
 241   1          // static u8 last_adc_sel = 0;
 242   1          // if (last_adc_sel == adc_sel_pin)
 243   1          // {
 244   1          //     // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€
             -€å‡º
 245   1          //     return;
 246   1          // }
 247   1      
 248   1          // last_adc_sel = adc_sel_pin;
 249   1      
 250   1          __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
 251   1          IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
 252   1      
 253   1          switch (adc_sel_pin)
 254   1          {
 255   2          case ADC_SEL_PIN_ENGINE:
 256   2          {
 257   3              // ADCé…ç½®
 258   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
 259   3              ADC_ACON1 |= ADC_VREF_SEL(0x5) |                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ
             -‰‹å†Œè¯´æœªæ ¡å‡†)
 260   3                           ADC_TEN_SEL(0x3);                           /* å…³é—­æµ‹è¯•ä¿¡å· */
 261   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                            // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
 262   3                          ADC_BIAS_EN(0x1) |                           // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 263   3                          ADC_BIAS_SEL(0x1);                           // åç½®ç”µæµï¼š1x
 264   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) |                       // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P2
             -7ï¼‰
 265   3                         ADC_EXT_SEL(0x0);                             // é€‰æ‹©å¤–éƒ¨é€šé“
 266   3          }
 267   2          break;
 268   2      
 269   2          case ADC_SEL_PIN_KNOB:
 270   2          {
 271   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 272   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
 273   3                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
 274   3              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
 275   3                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 276   3                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
 277   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
 278   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 279   3          }
 280   2          break;
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 6   

 281   2      
 282   2          case ADC_SEL_PIN_TEMP:
 283   2          {
 284   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹
 285   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
 286   3                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
 287   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
 288   3                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
 289   3                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
 290   3      
 291   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
 292   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 293   3          }
 294   2          break;
 295   2      
 296   2          case ADC_SEL_PIN_FAN:
 297   2          {
 298   3              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 299   3              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
 300   3                           ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å·
 301   3              ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„CMPä
             -½¿èƒ½ä¿¡å·
 302   3                          ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
 303   3                          ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1x
 304   3      
 305   3              ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
 306   3                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 307   3          }
 308   2          break;
 309   2      
 310   2          default:
 311   2              break;
 312   2          }
 313   1      
 314   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0
 315   1                      ADC_EN(0x1);        // ä½¿èƒ½adc
 316   1      }
 317          
 318          // adcå•æ¬¡é‡‡é›†+è½¬æ¢ï¼ˆæ²¡æœ‰æ»¤æ³¢ï¼‰
 319          // u16 adc_get_val_single(void)
 320          // {
 321          //     u16 adc_val = 0;
 322          //     ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 323          //     while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 324          //         ;                                            // ç­‰å¾…è½¬æ¢å®Œæˆ
 325          //     adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å–channel0çš„å€¼
 326          //     ADC_STA = ADC_CHAN0_DONE(0x1);                   // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 327          //     return adc_val;
 328          // }
 329          
 330          // è·å–ä¸€æ¬¡adcé‡‡é›†+æ»¤æ³¢åçš„å€¼
 331          // u16 adc_get_val(void)
 332          // {
 333          //     u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 334          //     volatile u16 g_temp_value = 0;
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 7   

 335          //     volatile u32 g_tmpbuff = 0;
 336          //     volatile u16 g_adcmax = 0;
 337          //     volatile u16 g_adcmin = 0xFFFF;
 338          
 339          //     // é‡‡é›†20æ¬¡ï¼Œå»æ‰å‰ä¸¤æ¬¡é‡‡æ ·ï¼Œå†å»æ‰ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼Œå†å–å¹³å‡å
             -€¼
 340          //     for (i = 0; i < 20; i++)
 341          //     {
 342          //         ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 343          //         while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 344          //             ;                                                 // ç­‰å¾…è½¬æ¢å®Œæˆ
 345          //         g_temp_value = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å– channel0 çš„å€¼
 346          //         ADC_STA = ADC_CHAN0_DONE(0x1);                        // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 347          
 348          //         if (i < 2)
 349          //             continue; // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·çš„
 350          //         if (g_temp_value > g_adcmax)
 351          //             g_adcmax = g_temp_value; // æœ€å¤§
 352          //         if (g_temp_value < g_adcmin)
 353          //             g_adcmin = g_temp_value; // æœ€å°
 354          
 355          //         g_tmpbuff += g_temp_value;
 356          //     }
 357          
 358          //     g_tmpbuff -= g_adcmax;           // å»æ‰ä¸€ä¸ªæœ€å¤§
 359          //     g_tmpbuff -= g_adcmin;           // å»æ‰ä¸€ä¸ªæœ€å°
 360          //     g_temp_value = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 361          
 362          //     return g_temp_value;
 363          // }
 364          
 365          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 366          u32 get_voltage_from_pin(void)
 367          {
 368   1          return (u32)adc_val_from_temp * 12 / 10;
 369   1      }
 370          
 371          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 372          void temperature_scan(void)
 373          {
 374   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 375   1      
 376   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 377   1          if (TEMP_75_5_MIN == temp_status)
 378   1          {
 379   2              return;
 380   2          }
 381   1      
 382   1          {
 383   2              // è°ƒç”¨è¯¥å‡½æ•°ä¸€å®šæ¬¡æ•°ä¹‹åï¼Œæ‰è¿›è¡Œæ¸©åº¦æ£€æµ‹ï¼Œç¼©çŸ­ä¸»å¾ªç¯çš„æ‰§è¡Œå‘¨æœŸ
 384   2              static volatile u8 cnt = 0;
 385   2              cnt++;
 386   2              if (cnt < 100)
 387   2              {
 388   3                  return;
 389   3              }
 390   2      
 391   2              cnt = 0;
 392   2          }
 393   1      
 394   1          voltage = get_voltage_from_pin(); // å¾—åˆ°çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 8   

 395   1      
 396   1      #if USE_MY_DEBUG
                  // printf("PIN-8 voltage: %lu mV\n", voltage);
              #endif // USE_MY_DEBUG
 399   1      
 400   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 401   1          // if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 402   1          if (TEMP_NORMAL == temp_status)
 403   1          {
 404   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 405   2              static volatile u8 cnt = 0;
 406   2              if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°
             -äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 407   2              {
 408   3                  cnt++;
 409   3              }
 410   2              else
 411   2              {
 412   3                  cnt = 0;
 413   3              }
 414   2      
 415   2              if (cnt >= 10)
 416   2              {
 417   3                  cnt = 0;
 418   3                  // æµ‹è¯•çš„æ—¶å€™ï¼Œå¦‚æœå¼•è„šæ‚¬ç©ºï¼Œå¯èƒ½ä¼šæ‰§è¡Œä¸åˆ°è¿™é‡Œï¼š
 419   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦   USER_TO_DO  åœ¨æµ‹è¯•æ—¶ä¼š
             -å±è”½æ‰
 420   3              }
 421   2              else
 422   2              {
 423   3                  temp_status = TEMP_NORMAL;
 424   3              }
 425   2      
 426   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 427   2          }
 428   1          else if (TEMP_75 == temp_status)
 429   1          {
 430   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 431   2              static bit tmr1_is_open = 0;
 432   2      
 433   2              if (0 == tmr1_is_open)
 434   2              {
 435   3                  tmr1_is_open = 1;
 436   3                  tmr1_cnt = 0;
 437   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡ä¸€å®šæ—¶é—´
 438   3              }
 439   2      
 440   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 441   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 442   2              {
 443   3                  static volatile u8 cnt = 0;
 444   3      
 445   3                  if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è
             -¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 446   3                  {
 447   4                      cnt++;
 448   4                  }
 449   3                  else
 450   3                  {
 451   4                      cnt = 0;
 452   4                  }
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 9   

 453   3      
 454   3                  if (cnt >= 10)
 455   3                  {
 456   4                      cnt = 0;
 457   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 458   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 459   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 460   4                      tmr1_is_open = 0;
 461   4                  }
 462   3                  else
 463   3                  {
 464   4                      temp_status = TEMP_75;
 465   4                  }
 466   3      
 467   3                  return;
 468   3              }
 469   2          }
 470   1      }
 471          
 472          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 473          void set_duty(void)
 474          {
 475   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 476   1          if (TEMP_NORMAL == temp_status)
 477   1          {
 478   2              if (flag_is_time_to_check_engine)
 479   2              {
 480   3                  flag_is_time_to_check_engine = 0;
 481   3                  according_pin9_to_adjust_pwm();
 482   3              }
 483   2          }
 484   1          else if (TEMP_75 == temp_status)
 485   1          {
 486   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 487   2          }
 488   1          else if (TEMP_75_5_MIN == temp_status)
 489   1          {
 490   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 491   2          }
 492   1      }
 493          
 494          // volatile u16 adc_val_pin_9_filter_count = 0;
 495          // u16 adc_val_pin_9_temp;
 496          // æ›´æ–°9è„šé‡‡é›†çš„adå€¼
 497          // void adc_update_pin_9_adc_val(void)
 498          // {
 499          //     adc_sel_pin(ADC_SEL_PIN_GET_VOL);
 500          //     adc_val_pin_9 = adc_get_val();
 501          
 502          //     // adc_val_pin_9 = 1000; // æµ‹è¯•æ—¶ä½¿ç”¨
 503          
 504          // #if USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 505          //     // printf("adc_val_pin_9 %u\n", adc_val_pin_9);
 506          
 507          //     // printf(",a=%u,", adc_val_pin_9);
 508          // #endif // USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 509          // }
 510          
 511          void fan_scan(void)
 512          {
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 10  

 513   1          u16 adc_val = adc_val_from_fan; // adc_val_from_fan ç”±adcä¸­æ–­è§¦å‘
 514   1      
 515   1          /*
 516   1              1è„šç”µå‹ä½äº4.3Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º25%å ç©ºæ¯”ï¼Œ
 517   1              1è„šç”µå‹é«˜äº4.5Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º100%å ç©ºæ¯”
 518   1          */
 519   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 520   1          {
 521   2              if (adc_val <= ADC_VAL_WHEN_FAN_ERR)
 522   2              {
 523   3                  flag_tim_scan_fan_is_err = 1; // è¡¨ç¤ºé£æ‰‡å¼‚å¸¸ï¼Œè®©å®šæ—¶å™¨ç´¯è®¡æ—¶é—´
 524   3              }
 525   2              else
 526   2              {
 527   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 528   3                  flag_tim_scan_fan_is_err = 0;
 529   3              }
 530   2      
 531   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 532   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 533   2          }
 534   1          else // FAN_STATUS_ERROR == cur_fan_status
 535   1          {
 536   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 537   2              if (adc_val >= ADC_VAL_WHEN_FAN_NORMAL)
 538   2              {
 539   3                  flag_tim_scan_fan_is_err = 0; // è¡¨ç¤ºé£æ‰‡æ­£å¸¸
 540   3              }
 541   2      
 542   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 543   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 544   2          }
 545   1      }
 546          
 547          void ADC_IRQHandler(void) interrupt ADC_IRQn
 548          {
 549   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 550   1          __IRQnIPnPush(ADC_IRQn);
 551   1      
 552   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 553   1      
 554   1      #if 0
                  if (ADC_STA & ADC_CHAN0_DONE(0x01))
                  {
                      ADC_STA |= ADC_CHAN0_DONE(0x01); // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
                      adc_val_from_engine = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4);
                  }
              
                  if (ADC_STA & ADC_CHAN1_DONE(0x01))
                  {
                      ADC_STA |= ADC_CHAN1_DONE(0x01); // æ¸…é™¤ADC1è½¬æ¢å®Œæˆæ ‡å¿—ä½
                      adc_val_from_knob = (ADC_DATAH1 << 4) | (ADC_DATAL1 >> 4);
                  }
              
                  if (ADC_STA & ADC_CHAN2_DONE(0x01))
                  {
                      ADC_STA |= ADC_CHAN2_DONE(0x01); // æ¸…é™¤ADC2è½¬æ¢å®Œæˆæ ‡å¿—ä½
              
                      if (ADC2_STATUS_SEL_GET_TEMP == cur_adc2_status)
                      {
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 11  

                          // å¦‚æœå½“å‰å¯¹åº”çš„æ˜¯è·å–æ¸©åº¦çš„adcé€šé“
                          adc_val_from_temp = (ADC_DATAH2 << 4) | (ADC_DATAL2 >> 4);
                      }
                      else if (ADC2_STATUS_SEL_FAN_DETECT == cur_adc2_status)
                      {
                          // å¦‚æœå½“å‰å¯¹åº”çš„æ˜¯æ£€æµ‹é£æ‰‡çš„adcé€šé“
                          adc_val_from_fan = (ADC_DATAH2 << 4) | (ADC_DATAL2 >> 4);
                      }
                  }
              #endif
 583   1      
 584   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 585   1          {
 586   2              volatile u16 adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 587   2              ADC_STA |= ADC_CHAN0_DONE(0x01);                              // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 588   2      
 589   2              if (ADC_STATUS_SEL_ENGINE == cur_adc_status)
 590   2              {
 591   3                  // æ›´æ–°å‘åŠ¨æœºæ£€æµ‹ä¸€ç«¯çš„adå€¼
 592   3      
 593   3                  static u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 594   3                  static volatile u32 g_tmpbuff = 0;
 595   3                  static volatile u16 g_adcmax = 0;
 596   3                  static volatile u16 g_adcmin = 0xFFFF;
 597   3      
 598   3                  if (i < 20)
 599   3                  {
 600   4                      i++;
 601   4      
 602   4                      if (i >= 2) // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·å€¼
 603   4                      {
 604   5                          if (adc_val > g_adcmax)
 605   5                              g_adcmax = adc_val; // æœ€å¤§
 606   5                          if (adc_val < g_adcmin)
 607   5                              g_adcmin = adc_val; // æœ€å°
 608   5                          g_tmpbuff += adc_val;
 609   5                      }
 610   4      
 611   4                      if (i < 20)
 612   4                          ADC_CFG0 |= 0x01 << 0; // å¼€å¯adc0è½¬æ¢
 613   4                  }
 614   3      
 615   3                  if (i >= 20)
 616   3                  {
 617   4                      adc_val_from_engine = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 618   4                      cur_adc_status = ADC_STATUS_SEL_ENGINE_DONE;
 619   4      
 620   4                      // é‡æ–°åˆå§‹åŒ–ä½¿ç”¨åˆ°çš„å˜é‡ï¼š
 621   4                      i = 0;
 622   4                      g_adcmax = 0;
 623   4                      g_adcmin = 0xFFFF;
 624   4                      g_tmpbuff = 0;
 625   4                      // printf("1 engine scan done\n");
 626   4                  }
 627   3              }
 628   2              else if (ADC_STATUS_SEL_KNOB == cur_adc_status)
 629   2              {
 630   3                  // æ›´æ–°æ—‹é’®æ£€æµ‹ä¸€ç«¯çš„adå€¼
 631   3                  adc_val_from_knob = adc_val;
 632   3                  // printf("2 knob scan done\n");
 633   3              }
 634   2              else if (ADC_STATUS_SEL_GET_TEMP == cur_adc_status)
C51 COMPILER V9.60.7.0   ADC                                                               01/17/2026 10:13:42 PAGE 12  

 635   2              {
 636   3                  // æ›´æ–°çƒ­æ•ç”µé˜»æ£€æµ‹ä¸€ç«¯çš„adå€¼
 637   3                  adc_val_from_temp = adc_val;
 638   3                  // printf("3 temp scan done\n");
 639   3              }
 640   2              else if (ADC_STATUS_SEL_FAN_DETECT == cur_adc_status)
 641   2              {
 642   3                  // æ›´æ–°é£æ‰‡æ£€æµ‹ä¸€ç«¯çš„adå€¼
 643   3                  adc_val_from_fan = adc_val;
 644   3                  // printf("4 fan scan done\n");
 645   3              }
 646   2          }
 647   1      
 648   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 649   1          __IRQnIPnPop(ADC_IRQn);
 650   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    838    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     56       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
